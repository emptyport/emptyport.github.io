<head>
  <title>Search</title>
  <link rel="shortcut icon" href="/images/favicon.png" type="image/png">
  <meta name="viewport" content="width=device-width, initial-scale=1" />    
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102894893-1', 'auto');
  ga('send', 'pageview');

</script>
</head>

<style>
  .icon {
    display: inline-block;
    width: 1em;
    height: 1em;
    stroke-width: 0;
    stroke: currentColor;
    fill: currentColor;
  }
  
  /* ==========================================
  Single-colored icons can be modified like so:
  .icon-name {
    font-size: 32px;
    color: red;
  }
  ========================================== */
  
  .icon-user {
    width: 0.7142857142857142em;
  }
  
  .icon-home {
    width: 0.9285714285714285em;
  }
  
  .icon-book {
    width: 0.9302142857142857em;
  }
  
  .icon-camera {
    width: 1.0714285714285714em;
  }
  
  .icon-arrow-left {
    width: 0.8928571428571428em;
  }
  
  .icon-flask {
    width: 0.9285714285714285em;
  }
  
  .icon-laptop {
    width: 1.0714285714285714em;
  }
  
  .icon-github {
    width: 0.8571428571428571em;
  }
  
  .icon-twitter {
    width: 0.9285714285714285em;
  }
  
  .icon-linkedin {
    width: 0.8571428571428571em;
  }
  
  .icon-instagram {
    width: 0.8571428571428571em;
  }
</style>

<svg style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<defs>
<symbol id="icon-user" viewBox="0 0 20 28">
<title>user</title>
<path d="M20 21.859c0 2.281-1.5 4.141-3.328 4.141h-13.344c-1.828 0-3.328-1.859-3.328-4.141 0-4.109 1.016-8.859 5.109-8.859 1.266 1.234 2.984 2 4.891 2s3.625-0.766 4.891-2c4.094 0 5.109 4.75 5.109 8.859zM16 8c0 3.313-2.688 6-6 6s-6-2.688-6-6 2.688-6 6-6 6 2.688 6 6z"></path>
</symbol>
<symbol id="icon-home" viewBox="0 0 26 28">
<title>home</title>
<path d="M22 15.5v7.5c0 0.547-0.453 1-1 1h-6v-6h-4v6h-6c-0.547 0-1-0.453-1-1v-7.5c0-0.031 0.016-0.063 0.016-0.094l8.984-7.406 8.984 7.406c0.016 0.031 0.016 0.063 0.016 0.094zM25.484 14.422l-0.969 1.156c-0.078 0.094-0.203 0.156-0.328 0.172h-0.047c-0.125 0-0.234-0.031-0.328-0.109l-10.813-9.016-10.813 9.016c-0.109 0.078-0.234 0.125-0.375 0.109-0.125-0.016-0.25-0.078-0.328-0.172l-0.969-1.156c-0.172-0.203-0.141-0.531 0.063-0.703l11.234-9.359c0.656-0.547 1.719-0.547 2.375 0l3.813 3.187v-3.047c0-0.281 0.219-0.5 0.5-0.5h3c0.281 0 0.5 0.219 0.5 0.5v6.375l3.422 2.844c0.203 0.172 0.234 0.5 0.063 0.703z"></path>
</symbol>
<symbol id="icon-book" viewBox="0 0 26 28">
<title>book</title>
<path d="M25.609 7.469c0.391 0.562 0.5 1.297 0.281 2.016l-4.297 14.156c-0.391 1.328-1.766 2.359-3.109 2.359h-14.422c-1.594 0-3.297-1.266-3.875-2.891-0.25-0.703-0.25-1.391-0.031-1.984 0.031-0.313 0.094-0.625 0.109-1 0.016-0.25-0.125-0.453-0.094-0.641 0.063-0.375 0.391-0.641 0.641-1.062 0.469-0.781 1-2.047 1.172-2.859 0.078-0.297-0.078-0.641 0-0.906 0.078-0.297 0.375-0.516 0.531-0.797 0.422-0.719 0.969-2.109 1.047-2.844 0.031-0.328-0.125-0.688-0.031-0.938 0.109-0.359 0.453-0.516 0.688-0.828 0.375-0.516 1-2 1.094-2.828 0.031-0.266-0.125-0.531-0.078-0.812 0.063-0.297 0.438-0.609 0.688-0.969 0.656-0.969 0.781-3.109 2.766-2.547l-0.016 0.047c0.266-0.063 0.531-0.141 0.797-0.141h11.891c0.734 0 1.391 0.328 1.781 0.875 0.406 0.562 0.5 1.297 0.281 2.031l-4.281 14.156c-0.734 2.406-1.141 2.938-3.125 2.938h-13.578c-0.203 0-0.453 0.047-0.594 0.234-0.125 0.187-0.141 0.328-0.016 0.672 0.313 0.906 1.391 1.094 2.25 1.094h14.422c0.578 0 1.25-0.328 1.422-0.891l4.688-15.422c0.094-0.297 0.094-0.609 0.078-0.891 0.359 0.141 0.688 0.359 0.922 0.672zM8.984 7.5c-0.094 0.281 0.063 0.5 0.344 0.5h9.5c0.266 0 0.562-0.219 0.656-0.5l0.328-1c0.094-0.281-0.063-0.5-0.344-0.5h-9.5c-0.266 0-0.562 0.219-0.656 0.5zM7.688 11.5c-0.094 0.281 0.063 0.5 0.344 0.5h9.5c0.266 0 0.562-0.219 0.656-0.5l0.328-1c0.094-0.281-0.063-0.5-0.344-0.5h-9.5c-0.266 0-0.562 0.219-0.656 0.5z"></path>
</symbol>
<symbol id="icon-camera" viewBox="0 0 30 28">
<title>camera</title>
<path d="M15 10.5c2.484 0 4.5 2.016 4.5 4.5s-2.016 4.5-4.5 4.5-4.5-2.016-4.5-4.5 2.016-4.5 4.5-4.5zM26 4c2.203 0 4 1.797 4 4v14c0 2.203-1.797 4-4 4h-22c-2.203 0-4-1.797-4-4v-14c0-2.203 1.797-4 4-4h3.5l0.797-2.125c0.391-1.031 1.609-1.875 2.703-1.875h8c1.094 0 2.312 0.844 2.703 1.875l0.797 2.125h3.5zM15 22c3.859 0 7-3.141 7-7s-3.141-7-7-7-7 3.141-7 7 3.141 7 7 7z"></path>
</symbol>
<symbol id="icon-arrow-left" viewBox="0 0 25 28">
<title>arrow-left</title>
<path d="M24 14v2c0 1.062-0.703 2-1.828 2h-11l4.578 4.594c0.375 0.359 0.594 0.875 0.594 1.406s-0.219 1.047-0.594 1.406l-1.172 1.188c-0.359 0.359-0.875 0.578-1.406 0.578s-1.047-0.219-1.422-0.578l-10.172-10.187c-0.359-0.359-0.578-0.875-0.578-1.406s0.219-1.047 0.578-1.422l10.172-10.156c0.375-0.375 0.891-0.594 1.422-0.594s1.031 0.219 1.406 0.594l1.172 1.156c0.375 0.375 0.594 0.891 0.594 1.422s-0.219 1.047-0.594 1.422l-4.578 4.578h11c1.125 0 1.828 0.938 1.828 2z"></path>
</symbol>
<symbol id="icon-flask" viewBox="0 0 26 28">
<title>flask</title>
<path d="M23.859 22.625c1.172 1.859 0.344 3.375-1.859 3.375h-18c-2.203 0-3.031-1.516-1.859-3.375l7.859-12.391v-6.234h-1c-0.547 0-1-0.453-1-1s0.453-1 1-1h8c0.547 0 1 0.453 1 1s-0.453 1-1 1h-1v6.234zM11.688 11.297l-4.25 6.703h11.125l-4.25-6.703-0.313-0.484v-6.813h-2v6.813z"></path>
</symbol>
<symbol id="icon-laptop" viewBox="0 0 30 28">
<title>laptop</title>
<path d="M6.5 20c-1.375 0-2.5-1.125-2.5-2.5v-11c0-1.375 1.125-2.5 2.5-2.5h17c1.375 0 2.5 1.125 2.5 2.5v11c0 1.375-1.125 2.5-2.5 2.5h-17zM6 6.5v11c0 0.266 0.234 0.5 0.5 0.5h17c0.266 0 0.5-0.234 0.5-0.5v-11c0-0.266-0.234-0.5-0.5-0.5h-17c-0.266 0-0.5 0.234-0.5 0.5zM27.5 21h2.5v1.5c0 0.828-1.125 1.5-2.5 1.5h-25c-1.375 0-2.5-0.672-2.5-1.5v-1.5h27.5zM16.25 22.5c0.141 0 0.25-0.109 0.25-0.25s-0.109-0.25-0.25-0.25h-2.5c-0.141 0-0.25 0.109-0.25 0.25s0.109 0.25 0.25 0.25h2.5z"></path>
</symbol>
<symbol id="icon-brush" viewBox="0 0 28 28">
<title>paint-brush</title>
<path d="M25.234 0c1.422 0 2.734 1.062 2.734 2.547 0 0.828-0.328 1.625-0.703 2.359-1.219 2.312-5.313 9.953-7.266 11.75-0.953 0.891-2.078 1.422-3.406 1.422-2.641 0-4.797-2.25-4.797-4.875 0-1.25 0.516-2.469 1.437-3.313l9.969-9.047c0.547-0.5 1.266-0.844 2.031-0.844zM11.031 16.156c0.812 1.578 2.297 2.766 4.016 3.219l0.016 1.109c0.094 4.453-3 7.516-7.469 7.516-5.297 0-7.594-4.219-7.594-9.016 0.578 0.391 2.594 2 3.25 2 0.391 0 0.719-0.219 0.859-0.578 1.328-3.469 3.406-4.094 6.922-4.25z"></path>
</symbol>
<symbol id="icon-instagram" viewBox="0 0 24 28">
<title>instagram</title>
<path d="M16 14c0-2.203-1.797-4-4-4s-4 1.797-4 4 1.797 4 4 4 4-1.797 4-4zM18.156 14c0 3.406-2.75 6.156-6.156 6.156s-6.156-2.75-6.156-6.156 2.75-6.156 6.156-6.156 6.156 2.75 6.156 6.156zM19.844 7.594c0 0.797-0.641 1.437-1.437 1.437s-1.437-0.641-1.437-1.437 0.641-1.437 1.437-1.437 1.437 0.641 1.437 1.437zM12 4.156c-1.75 0-5.5-0.141-7.078 0.484-0.547 0.219-0.953 0.484-1.375 0.906s-0.688 0.828-0.906 1.375c-0.625 1.578-0.484 5.328-0.484 7.078s-0.141 5.5 0.484 7.078c0.219 0.547 0.484 0.953 0.906 1.375s0.828 0.688 1.375 0.906c1.578 0.625 5.328 0.484 7.078 0.484s5.5 0.141 7.078-0.484c0.547-0.219 0.953-0.484 1.375-0.906s0.688-0.828 0.906-1.375c0.625-1.578 0.484-5.328 0.484-7.078s0.141-5.5-0.484-7.078c-0.219-0.547-0.484-0.953-0.906-1.375s-0.828-0.688-1.375-0.906c-1.578-0.625-5.328-0.484-7.078-0.484zM24 14c0 1.656 0.016 3.297-0.078 4.953-0.094 1.922-0.531 3.625-1.937 5.031s-3.109 1.844-5.031 1.937c-1.656 0.094-3.297 0.078-4.953 0.078s-3.297 0.016-4.953-0.078c-1.922-0.094-3.625-0.531-5.031-1.937s-1.844-3.109-1.937-5.031c-0.094-1.656-0.078-3.297-0.078-4.953s-0.016-3.297 0.078-4.953c0.094-1.922 0.531-3.625 1.937-5.031s3.109-1.844 5.031-1.937c1.656-0.094 3.297-0.078 4.953-0.078s3.297-0.016 4.953 0.078c1.922 0.094 3.625 0.531 5.031 1.937s1.844 3.109 1.937 5.031c0.094 1.656 0.078 3.297 0.078 4.953z"></path>
</symbol>
<symbol id="icon-linkedin" viewBox="0 0 24 28">
<title>linkedin</title>
<path d="M5.453 9.766v15.484h-5.156v-15.484h5.156zM5.781 4.984c0.016 1.484-1.109 2.672-2.906 2.672v0h-0.031c-1.734 0-2.844-1.188-2.844-2.672 0-1.516 1.156-2.672 2.906-2.672 1.766 0 2.859 1.156 2.875 2.672zM24 16.375v8.875h-5.141v-8.281c0-2.078-0.75-3.5-2.609-3.5-1.422 0-2.266 0.953-2.641 1.875-0.125 0.344-0.172 0.797-0.172 1.266v8.641h-5.141c0.063-14.031 0-15.484 0-15.484h5.141v2.25h-0.031c0.672-1.062 1.891-2.609 4.672-2.609 3.391 0 5.922 2.219 5.922 6.969z"></path>
</symbol>
<symbol id="icon-twitter" viewBox="0 0 26 28">
<title>twitter</title>
<path d="M25.312 6.375c-0.688 1-1.547 1.891-2.531 2.609 0.016 0.219 0.016 0.438 0.016 0.656 0 6.672-5.078 14.359-14.359 14.359-2.859 0-5.516-0.828-7.75-2.266 0.406 0.047 0.797 0.063 1.219 0.063 2.359 0 4.531-0.797 6.266-2.156-2.219-0.047-4.078-1.5-4.719-3.5 0.313 0.047 0.625 0.078 0.953 0.078 0.453 0 0.906-0.063 1.328-0.172-2.312-0.469-4.047-2.5-4.047-4.953v-0.063c0.672 0.375 1.453 0.609 2.281 0.641-1.359-0.906-2.25-2.453-2.25-4.203 0-0.938 0.25-1.797 0.688-2.547 2.484 3.062 6.219 5.063 10.406 5.281-0.078-0.375-0.125-0.766-0.125-1.156 0-2.781 2.25-5.047 5.047-5.047 1.453 0 2.766 0.609 3.687 1.594 1.141-0.219 2.234-0.641 3.203-1.219-0.375 1.172-1.172 2.156-2.219 2.781 1.016-0.109 2-0.391 2.906-0.781z"></path>
</symbol>
<symbol id="icon-github" viewBox="0 0 24 28">
<title>github</title>
<path d="M12 2c6.625 0 12 5.375 12 12 0 5.297-3.437 9.797-8.203 11.391-0.609 0.109-0.828-0.266-0.828-0.578 0-0.391 0.016-1.687 0.016-3.297 0-1.125-0.375-1.844-0.812-2.219 2.672-0.297 5.484-1.313 5.484-5.922 0-1.313-0.469-2.375-1.234-3.219 0.125-0.313 0.531-1.531-0.125-3.187-1-0.313-3.297 1.234-3.297 1.234-0.953-0.266-1.984-0.406-3-0.406s-2.047 0.141-3 0.406c0 0-2.297-1.547-3.297-1.234-0.656 1.656-0.25 2.875-0.125 3.187-0.766 0.844-1.234 1.906-1.234 3.219 0 4.594 2.797 5.625 5.469 5.922-0.344 0.313-0.656 0.844-0.766 1.609-0.688 0.313-2.438 0.844-3.484-1-0.656-1.141-1.844-1.234-1.844-1.234-1.172-0.016-0.078 0.734-0.078 0.734 0.781 0.359 1.328 1.75 1.328 1.75 0.703 2.141 4.047 1.422 4.047 1.422 0 1 0.016 1.937 0.016 2.234 0 0.313-0.219 0.688-0.828 0.578-4.766-1.594-8.203-6.094-8.203-11.391 0-6.625 5.375-12 12-12zM4.547 19.234c0.031-0.063-0.016-0.141-0.109-0.187-0.094-0.031-0.172-0.016-0.203 0.031-0.031 0.063 0.016 0.141 0.109 0.187 0.078 0.047 0.172 0.031 0.203-0.031zM5.031 19.766c0.063-0.047 0.047-0.156-0.031-0.25-0.078-0.078-0.187-0.109-0.25-0.047-0.063 0.047-0.047 0.156 0.031 0.25 0.078 0.078 0.187 0.109 0.25 0.047zM5.5 20.469c0.078-0.063 0.078-0.187 0-0.297-0.063-0.109-0.187-0.156-0.266-0.094-0.078 0.047-0.078 0.172 0 0.281s0.203 0.156 0.266 0.109zM6.156 21.125c0.063-0.063 0.031-0.203-0.063-0.297-0.109-0.109-0.25-0.125-0.313-0.047-0.078 0.063-0.047 0.203 0.063 0.297 0.109 0.109 0.25 0.125 0.313 0.047zM7.047 21.516c0.031-0.094-0.063-0.203-0.203-0.25-0.125-0.031-0.266 0.016-0.297 0.109s0.063 0.203 0.203 0.234c0.125 0.047 0.266 0 0.297-0.094zM8.031 21.594c0-0.109-0.125-0.187-0.266-0.172-0.141 0-0.25 0.078-0.25 0.172 0 0.109 0.109 0.187 0.266 0.172 0.141 0 0.25-0.078 0.25-0.172zM8.937 21.438c-0.016-0.094-0.141-0.156-0.281-0.141-0.141 0.031-0.234 0.125-0.219 0.234 0.016 0.094 0.141 0.156 0.281 0.125s0.234-0.125 0.219-0.219z"></path>
</symbol>
</defs>
</svg>

<script>
  /*
 * Copyright 2016 Small Batch, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
/* Web Font Loader v1.6.26 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.m=b||a;this.c=this.m.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function z(a){if("string"===typeof a.f)return a.f;var b=a.m.location.protocol;"about:"==b&&(b=a.a.location.protocol);return"https:"==b?"https:":"http:"}function ea(a){return a.m.location.hostname||a.a.location.hostname}
function A(a,b,c){function d(){k&&e&&f&&(k(g),k=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,k=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function B(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function C(){this.a=0;this.c=null}function D(a){a.a++;return function(){a.a--;E(a)}}function F(a,b){a.c=b;E(a)}function E(a){0==a.a&&a.c&&(a.c(),a.c=null)};function G(a){this.a=a||"-"}G.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function H(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return I(a)+" "+(a.f+"00")+" 300px "+J(a.c)}function J(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function K(a){return a.a+a.f}function I(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.m.document.documentElement;this.h=b;this.a=new G("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);L(a,"loading")}function M(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}L(a,"inactive")}function L(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,K(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function N(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function O(a){u(a.c,"body",a.a)}function P(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+J(a.c)+";"+("font-style:"+I(a)+";font-weight:"+(a.f+"00")+";")};function Q(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}Q.prototype.start=function(){var a=this.c.m.document,b=this,c=q(),d=new Promise(function(d,e){function k(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(k,25)},function(){e()})}k()}),e=new Promise(function(a,d){setTimeout(d,b.f)});Promise.race([e,d]).then(function(){b.g(b.a)},function(){b.j(b.a)})};function R(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.o=this.j=this.h=this.g=null;this.g=new N(this.c,this.s);this.h=new N(this.c,this.s);this.j=new N(this.c,this.s);this.o=new N(this.c,this.s);a=new H(this.a.c+",serif",K(this.a));a=P(a);this.g.a.style.cssText=a;a=new H(this.a.c+",sans-serif",K(this.a));a=P(a);this.h.a.style.cssText=a;a=new H("serif",K(this.a));a=P(a);this.j.a.style.cssText=a;a=new H("sans-serif",K(this.a));a=
P(a);this.o.a.style.cssText=a;O(this.g);O(this.h);O(this.j);O(this.o)}var S={D:"serif",C:"sans-serif"},T=null;function U(){if(null===T){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);T=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return T}R.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.o.a.offsetWidth;this.A=q();la(this)};
function ma(a,b,c){for(var d in S)if(S.hasOwnProperty(d)&&b===a.f[S[d]]&&c===a.f[S[d]])return!0;return!1}function la(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=U()&&ma(a,b,c));d?q()-a.A>=a.w?U()&&ma(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):na(a):V(a,a.v)}function na(a){setTimeout(p(function(){la(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.o.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.o=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,K(a).toString(),"active")],[b.a.c("wf",a.c,K(a).toString(),"loading"),b.a.c("wf",a.c,K(a).toString(),"inactive")]);L(b,"fontactive",a);this.o=!0;oa(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,K(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,K(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,K(a).toString(),"inactive"));w(b.f,d,e)}L(b,"fontinactive",a);oa(this)};function oa(a){0==--a.f&&a.j&&(a.o?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),L(a,"active")):M(a.a))};function pa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}pa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;qa(this,new ha(this.c,a),a)};
function ra(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,k=d||null||{};if(0===c.length&&f)M(b.a);else{b.f+=c.length;f&&(b.j=f);var h,m=[];for(h=0;h<c.length;h++){var l=c[h],n=k[l.c],r=b.a,x=l;r.g&&w(r.f,[r.a.c("wf",x.c,K(x).toString(),"loading")]);L(r,"fontloading",x);r=null;null===X&&(X=window.FontFace?(x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent))?42<parseInt(x[1],10):!0:!1);X?r=new Q(p(b.g,b),p(b.h,b),b.c,l,b.s,n):r=new R(p(b.g,b),p(b.h,b),b.c,l,b.s,a,
n);m.push(r)}for(h=0;h<m.length;h++)m[h].start()}},0)}function qa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){ra(a,f,b,d,c)})};function sa(a,b){this.c=a;this.a=b}function ta(a,b,c){var d=z(a.c);a=(a.a.api||"fast.fonts.net/jsapi").replace(/^.*http(s?):(\/\/)?/,"");return d+"//"+a+"/"+b+".js"+(c?"?v="+c:"")}
sa.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var m=0;m<c.length;m++){var l=c[m].fontfamily;void 0!=c[m].fontStyle&&void 0!=c[m].fontWeight?(h=c[m].fontStyle+c[m].fontWeight,e.push(new H(l,h))):e.push(new H(l))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.m;B(this.c,ta(c,d,e),function(e){e?a([]):(f["__MonotypeConfiguration__"+d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+
d}else a([])};function ua(a,b){this.c=a;this.a=b}ua.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new C;b=0;for(c=d.length;b<c;b++)A(this.c,d[b],D(g));var k=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),m=0;m<h.length;m+=1)k.push(new H(d[0],h[m]));else k.push(new H(d[0]));F(g,function(){a(k,f)})};function va(a,b,c){a?this.c=a:this.c=b+wa;this.a=[];this.f=[];this.g=c||""}var wa="//fonts.googleapis.com/css";function xa(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function ya(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function za(a){this.f=a;this.a=[];this.c={}}
var Aa={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Ba={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ca={i:"i",italic:"i",n:"n",normal:"n"},
Da=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Ea(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var k=d[1];g=[];if(k)for(var k=k.split(","),h=k.length,m=0;m<h;m++){var l;l=k[m];if(l.match(/^[\w-]+$/)){var n=Da.exec(l.toLowerCase());if(null==n)l="";else{l=n[2];l=null==l||""==l?"n":Ca[l];n=n[1];if(null==n||""==n)n="4";else var r=Ba[n],n=r?r:isNaN(n)?"4":n.substr(0,1);l=[l,n].join("")}}else l="";l&&g.push(l)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=Aa[d[0]])&&(a.c[e]=d))}a.c[e]||(d=Aa[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new H(e,f[d]))}};function Fa(a,b){this.c=a;this.a=b}var Ga={Arimo:!0,Cousine:!0,Tinos:!0};Fa.prototype.load=function(a){var b=new C,c=this.c,d=new va(this.a.api,z(c),this.a.text),e=this.a.families;xa(d,e);var f=new za(e);Ea(f);A(c,ya(d),D(b));F(b,function(){a(f.a,f.c,Ga)})};function Ha(a,b){this.c=a;this.a=b}Ha.prototype.load=function(a){var b=this.a.id,c=this.c.m;b?B(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],k=b[f+1],h=0;h<k.length;h++)e.push(new H(g,k[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(m){}a(e)}},2E3):a([])};function Ia(a,b){this.c=a;this.f=b;this.a=[]}Ia.prototype.load=function(a){var b=this.f.id,c=this.c.m,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,k=c.fonts.length;g<k;++g){var h=c.fonts[g];d.a.push(new H(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},B(this.c,z(this.c)+(this.f.api||"//f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new pa(window);Y.a.c.custom=function(a,b){return new ua(b,a)};Y.a.c.fontdeck=function(a,b){return new Ia(b,a)};Y.a.c.monotype=function(a,b){return new sa(b,a)};Y.a.c.typekit=function(a,b){return new Ha(b,a)};Y.a.c.google=function(a,b){return new Fa(b,a)};var Z={load:p(Y.load,Y)};"function"===typeof define&&define.amd?define(function(){return Z}):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());
</script>

<script>
  WebFont.load({
    google: {
      families: ['Ubuntu']
    }
  });
</script> 



<script>
  /**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.1.3
 * Copyright (C) 2017 Oliver Nightingale
 * @license MIT
 */

;(function(){
  
  /**
   * A convenience function for configuring and constructing
   * a new lunr Index.
   *
   * A lunr.Builder instance is created and the pipeline setup
   * with a trimmer, stop word filter and stemmer.
   *
   * This builder object is yielded to the configuration function
   * that is passed as a parameter, allowing the list of fields
   * and other builder parameters to be customised.
   *
   * All documents _must_ be added within the passed config function.
   *
   * @example
   * var idx = lunr(function () {
   *   this.field('title')
   *   this.field('body')
   *   this.ref('id')
   *
   *   documents.forEach(function (doc) {
   *     this.add(doc)
   *   }, this)
   * })
   *
   * @see {@link lunr.Builder}
   * @see {@link lunr.Pipeline}
   * @see {@link lunr.trimmer}
   * @see {@link lunr.stopWordFilter}
   * @see {@link lunr.stemmer}
   * @namespace {function} lunr
   */
  var lunr = function (config) {
    var builder = new lunr.Builder
  
    builder.pipeline.add(
      lunr.trimmer,
      lunr.stopWordFilter,
      lunr.stemmer
    )
  
    builder.searchPipeline.add(
      lunr.stemmer
    )
  
    config.call(builder, builder)
    return builder.build()
  }
  
  lunr.version = "2.1.3"
  /*!
   * lunr.utils
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * A namespace containing utils for the rest of the lunr library
   */
  lunr.utils = {}
  
  /**
   * Print a warning message to the console.
   *
   * @param {String} message The message to be printed.
   * @memberOf Utils
   */
  lunr.utils.warn = (function (global) {
    /* eslint-disable no-console */
    return function (message) {
      if (global.console && console.warn) {
        console.warn(message)
      }
    }
    /* eslint-enable no-console */
  })(this)
  
  /**
   * Convert an object to a string.
   *
   * In the case of `null` and `undefined` the function returns
   * the empty string, in all other cases the result of calling
   * `toString` on the passed object is returned.
   *
   * @param {Any} obj The object to convert to a string.
   * @return {String} string representation of the passed object.
   * @memberOf Utils
   */
  lunr.utils.asString = function (obj) {
    if (obj === void 0 || obj === null) {
      return ""
    } else {
      return obj.toString()
    }
  }
  lunr.FieldRef = function (docRef, fieldName) {
    this.docRef = docRef
    this.fieldName = fieldName
    this._stringValue = fieldName + lunr.FieldRef.joiner + docRef
  }
  
  lunr.FieldRef.joiner = "/"
  
  lunr.FieldRef.fromString = function (s) {
    var n = s.indexOf(lunr.FieldRef.joiner)
  
    if (n === -1) {
      throw "malformed field ref string"
    }
  
    var fieldRef = s.slice(0, n),
        docRef = s.slice(n + 1)
  
    return new lunr.FieldRef (docRef, fieldRef)
  }
  
  lunr.FieldRef.prototype.toString = function () {
    return this._stringValue
  }
  /**
   * A function to calculate the inverse document frequency for
   * a posting. This is shared between the builder and the index
   *
   * @private
   * @param {object} posting - The posting for a given term
   * @param {number} documentCount - The total number of documents.
   */
  lunr.idf = function (posting, documentCount) {
    var documentsWithTerm = 0
  
    for (var fieldName in posting) {
      if (fieldName == '_index') continue // Ignore the term index, its not a field
      documentsWithTerm += Object.keys(posting[fieldName]).length
    }
  
    var x = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5)
  
    return Math.log(1 + Math.abs(x))
  }
  
  /**
   * A token wraps a string representation of a token
   * as it is passed through the text processing pipeline.
   *
   * @constructor
   * @param {string} [str=''] - The string token being wrapped.
   * @param {object} [metadata={}] - Metadata associated with this token.
   */
  lunr.Token = function (str, metadata) {
    this.str = str || ""
    this.metadata = metadata || {}
  }
  
  /**
   * Returns the token string that is being wrapped by this object.
   *
   * @returns {string}
   */
  lunr.Token.prototype.toString = function () {
    return this.str
  }
  
  /**
   * A token update function is used when updating or optionally
   * when cloning a token.
   *
   * @callback lunr.Token~updateFunction
   * @param {string} str - The string representation of the token.
   * @param {Object} metadata - All metadata associated with this token.
   */
  
  /**
   * Applies the given function to the wrapped string token.
   *
   * @example
   * token.update(function (str, metadata) {
   *   return str.toUpperCase()
   * })
   *
   * @param {lunr.Token~updateFunction} fn - A function to apply to the token string.
   * @returns {lunr.Token}
   */
  lunr.Token.prototype.update = function (fn) {
    this.str = fn(this.str, this.metadata)
    return this
  }
  
  /**
   * Creates a clone of this token. Optionally a function can be
   * applied to the cloned token.
   *
   * @param {lunr.Token~updateFunction} [fn] - An optional function to apply to the cloned token.
   * @returns {lunr.Token}
   */
  lunr.Token.prototype.clone = function (fn) {
    fn = fn || function (s) { return s }
    return new lunr.Token (fn(this.str, this.metadata), this.metadata)
  }
  /*!
   * lunr.tokenizer
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * A function for splitting a string into tokens ready to be inserted into
   * the search index. Uses `lunr.tokenizer.separator` to split strings, change
   * the value of this property to change how strings are split into tokens.
   *
   * This tokenizer will convert its parameter to a string by calling `toString` and
   * then will split this string on the character in `lunr.tokenizer.separator`.
   * Arrays will have their elements converted to strings and wrapped in a lunr.Token.
   *
   * @static
   * @param {?(string|object|object[])} obj - The object to convert into tokens
   * @returns {lunr.Token[]}
   */
  lunr.tokenizer = function (obj) {
    if (obj == null || obj == undefined) {
      return []
    }
  
    if (Array.isArray(obj)) {
      return obj.map(function (t) {
        return new lunr.Token(lunr.utils.asString(t).toLowerCase())
      })
    }
  
    var str = obj.toString().trim().toLowerCase(),
        len = str.length,
        tokens = []
  
    for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {
      var char = str.charAt(sliceEnd),
          sliceLength = sliceEnd - sliceStart
  
      if ((char.match(lunr.tokenizer.separator) || sliceEnd == len)) {
  
        if (sliceLength > 0) {
          tokens.push(
            new lunr.Token (str.slice(sliceStart, sliceEnd), {
              position: [sliceStart, sliceLength],
              index: tokens.length
            })
          )
        }
  
        sliceStart = sliceEnd + 1
      }
  
    }
  
    return tokens
  }
  
  /**
   * The separator used to split a string into tokens. Override this property to change the behaviour of
   * `lunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.
   *
   * @static
   * @see lunr.tokenizer
   */
  lunr.tokenizer.separator = /[\s\-]+/
  /*!
   * lunr.Pipeline
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * lunr.Pipelines maintain an ordered list of functions to be applied to all
   * tokens in documents entering the search index and queries being ran against
   * the index.
   *
   * An instance of lunr.Index created with the lunr shortcut will contain a
   * pipeline with a stop word filter and an English language stemmer. Extra
   * functions can be added before or after either of these functions or these
   * default functions can be removed.
   *
   * When run the pipeline will call each function in turn, passing a token, the
   * index of that token in the original list of all tokens and finally a list of
   * all the original tokens.
   *
   * The output of functions in the pipeline will be passed to the next function
   * in the pipeline. To exclude a token from entering the index the function
   * should return undefined, the rest of the pipeline will not be called with
   * this token.
   *
   * For serialisation of pipelines to work, all functions used in an instance of
   * a pipeline should be registered with lunr.Pipeline. Registered functions can
   * then be loaded. If trying to load a serialised pipeline that uses functions
   * that are not registered an error will be thrown.
   *
   * If not planning on serialising the pipeline then registering pipeline functions
   * is not necessary.
   *
   * @constructor
   */
  lunr.Pipeline = function () {
    this._stack = []
  }
  
  lunr.Pipeline.registeredFunctions = Object.create(null)
  
  /**
   * A pipeline function maps lunr.Token to lunr.Token. A lunr.Token contains the token
   * string as well as all known metadata. A pipeline function can mutate the token string
   * or mutate (or add) metadata for a given token.
   *
   * A pipeline function can indicate that the passed token should be discarded by returning
   * null. This token will not be passed to any downstream pipeline functions and will not be
   * added to the index.
   *
   * Multiple tokens can be returned by returning an array of tokens. Each token will be passed
   * to any downstream pipeline functions and all will returned tokens will be added to the index.
   *
   * Any number of pipeline functions may be chained together using a lunr.Pipeline.
   *
   * @interface lunr.PipelineFunction
   * @param {lunr.Token} token - A token from the document being processed.
   * @param {number} i - The index of this token in the complete list of tokens for this document/field.
   * @param {lunr.Token[]} tokens - All tokens for this document/field.
   * @returns {(?lunr.Token|lunr.Token[])}
   */
  
  /**
   * Register a function with the pipeline.
   *
   * Functions that are used in the pipeline should be registered if the pipeline
   * needs to be serialised, or a serialised pipeline needs to be loaded.
   *
   * Registering a function does not add it to a pipeline, functions must still be
   * added to instances of the pipeline for them to be used when running a pipeline.
   *
   * @param {lunr.PipelineFunction} fn - The function to check for.
   * @param {String} label - The label to register this function with
   */
  lunr.Pipeline.registerFunction = function (fn, label) {
    if (label in this.registeredFunctions) {
      lunr.utils.warn('Overwriting existing registered function: ' + label)
    }
  
    fn.label = label
    lunr.Pipeline.registeredFunctions[fn.label] = fn
  }
  
  /**
   * Warns if the function is not registered as a Pipeline function.
   *
   * @param {lunr.PipelineFunction} fn - The function to check for.
   * @private
   */
  lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {
    var isRegistered = fn.label && (fn.label in this.registeredFunctions)
  
    if (!isRegistered) {
      lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn)
    }
  }
  
  /**
   * Loads a previously serialised pipeline.
   *
   * All functions to be loaded must already be registered with lunr.Pipeline.
   * If any function from the serialised data has not been registered then an
   * error will be thrown.
   *
   * @param {Object} serialised - The serialised pipeline to load.
   * @returns {lunr.Pipeline}
   */
  lunr.Pipeline.load = function (serialised) {
    var pipeline = new lunr.Pipeline
  
    serialised.forEach(function (fnName) {
      var fn = lunr.Pipeline.registeredFunctions[fnName]
  
      if (fn) {
        pipeline.add(fn)
      } else {
        throw new Error('Cannot load unregistered function: ' + fnName)
      }
    })
  
    return pipeline
  }
  
  /**
   * Adds new functions to the end of the pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {lunr.PipelineFunction[]} functions - Any number of functions to add to the pipeline.
   */
  lunr.Pipeline.prototype.add = function () {
    var fns = Array.prototype.slice.call(arguments)
  
    fns.forEach(function (fn) {
      lunr.Pipeline.warnIfFunctionNotRegistered(fn)
      this._stack.push(fn)
    }, this)
  }
  
  /**
   * Adds a single function after a function that already exists in the
   * pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.
   * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.
   */
  lunr.Pipeline.prototype.after = function (existingFn, newFn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(newFn)
  
    var pos = this._stack.indexOf(existingFn)
    if (pos == -1) {
      throw new Error('Cannot find existingFn')
    }
  
    pos = pos + 1
    this._stack.splice(pos, 0, newFn)
  }
  
  /**
   * Adds a single function before a function that already exists in the
   * pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.
   * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.
   */
  lunr.Pipeline.prototype.before = function (existingFn, newFn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(newFn)
  
    var pos = this._stack.indexOf(existingFn)
    if (pos == -1) {
      throw new Error('Cannot find existingFn')
    }
  
    this._stack.splice(pos, 0, newFn)
  }
  
  /**
   * Removes a function from the pipeline.
   *
   * @param {lunr.PipelineFunction} fn The function to remove from the pipeline.
   */
  lunr.Pipeline.prototype.remove = function (fn) {
    var pos = this._stack.indexOf(fn)
    if (pos == -1) {
      return
    }
  
    this._stack.splice(pos, 1)
  }
  
  /**
   * Runs the current list of functions that make up the pipeline against the
   * passed tokens.
   *
   * @param {Array} tokens The tokens to run through the pipeline.
   * @returns {Array}
   */
  lunr.Pipeline.prototype.run = function (tokens) {
    var stackLength = this._stack.length
  
    for (var i = 0; i < stackLength; i++) {
      var fn = this._stack[i]
  
      tokens = tokens.reduce(function (memo, token, j) {
        var result = fn(token, j, tokens)
  
        if (result === void 0 || result === '') return memo
  
        return memo.concat(result)
      }, [])
    }
  
    return tokens
  }
  
  /**
   * Convenience method for passing a string through a pipeline and getting
   * strings out. This method takes care of wrapping the passed string in a
   * token and mapping the resulting tokens back to strings.
   *
   * @param {string} str - The string to pass through the pipeline.
   * @returns {string[]}
   */
  lunr.Pipeline.prototype.runString = function (str) {
    var token = new lunr.Token (str)
  
    return this.run([token]).map(function (t) {
      return t.toString()
    })
  }
  
  /**
   * Resets the pipeline by removing any existing processors.
   *
   */
  lunr.Pipeline.prototype.reset = function () {
    this._stack = []
  }
  
  /**
   * Returns a representation of the pipeline ready for serialisation.
   *
   * Logs a warning if the function has not been registered.
   *
   * @returns {Array}
   */
  lunr.Pipeline.prototype.toJSON = function () {
    return this._stack.map(function (fn) {
      lunr.Pipeline.warnIfFunctionNotRegistered(fn)
  
      return fn.label
    })
  }
  /*!
   * lunr.Vector
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * A vector is used to construct the vector space of documents and queries. These
   * vectors support operations to determine the similarity between two documents or
   * a document and a query.
   *
   * Normally no parameters are required for initializing a vector, but in the case of
   * loading a previously dumped vector the raw elements can be provided to the constructor.
   *
   * For performance reasons vectors are implemented with a flat array, where an elements
   * index is immediately followed by its value. E.g. [index, value, index, value]. This
   * allows the underlying array to be as sparse as possible and still offer decent
   * performance when being used for vector calculations.
   *
   * @constructor
   * @param {Number[]} [elements] - The flat list of element index and element value pairs.
   */
  lunr.Vector = function (elements) {
    this._magnitude = 0
    this.elements = elements || []
  }
  
  
  /**
   * Calculates the position within the vector to insert a given index.
   *
   * This is used internally by insert and upsert. If there are duplicate indexes then
   * the position is returned as if the value for that index were to be updated, but it
   * is the callers responsibility to check whether there is a duplicate at that index
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @returns {Number}
   */
  lunr.Vector.prototype.positionForIndex = function (index) {
    // For an empty vector the tuple can be inserted at the beginning
    if (this.elements.length == 0) {
      return 0
    }
  
    var start = 0,
        end = this.elements.length / 2,
        sliceLength = end - start,
        pivotPoint = Math.floor(sliceLength / 2),
        pivotIndex = this.elements[pivotPoint * 2]
  
    while (sliceLength > 1) {
      if (pivotIndex < index) {
        start = pivotPoint
      }
  
      if (pivotIndex > index) {
        end = pivotPoint
      }
  
      if (pivotIndex == index) {
        break
      }
  
      sliceLength = end - start
      pivotPoint = start + Math.floor(sliceLength / 2)
      pivotIndex = this.elements[pivotPoint * 2]
    }
  
    if (pivotIndex == index) {
      return pivotPoint * 2
    }
  
    if (pivotIndex > index) {
      return pivotPoint * 2
    }
  
    if (pivotIndex < index) {
      return (pivotPoint + 1) * 2
    }
  }
  
  /**
   * Inserts an element at an index within the vector.
   *
   * Does not allow duplicates, will throw an error if there is already an entry
   * for this index.
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @param {Number} val - The value to be inserted into the vector.
   */
  lunr.Vector.prototype.insert = function (insertIdx, val) {
    this.upsert(insertIdx, val, function () {
      throw "duplicate index"
    })
  }
  
  /**
   * Inserts or updates an existing index within the vector.
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @param {Number} val - The value to be inserted into the vector.
   * @param {function} fn - A function that is called for updates, the existing value and the
   * requested value are passed as arguments
   */
  lunr.Vector.prototype.upsert = function (insertIdx, val, fn) {
    this._magnitude = 0
    var position = this.positionForIndex(insertIdx)
  
    if (this.elements[position] == insertIdx) {
      this.elements[position + 1] = fn(this.elements[position + 1], val)
    } else {
      this.elements.splice(position, 0, insertIdx, val)
    }
  }
  
  /**
   * Calculates the magnitude of this vector.
   *
   * @returns {Number}
   */
  lunr.Vector.prototype.magnitude = function () {
    if (this._magnitude) return this._magnitude
  
    var sumOfSquares = 0,
        elementsLength = this.elements.length
  
    for (var i = 1; i < elementsLength; i += 2) {
      var val = this.elements[i]
      sumOfSquares += val * val
    }
  
    return this._magnitude = Math.sqrt(sumOfSquares)
  }
  
  /**
   * Calculates the dot product of this vector and another vector.
   *
   * @param {lunr.Vector} otherVector - The vector to compute the dot product with.
   * @returns {Number}
   */
  lunr.Vector.prototype.dot = function (otherVector) {
    var dotProduct = 0,
        a = this.elements, b = otherVector.elements,
        aLen = a.length, bLen = b.length,
        aVal = 0, bVal = 0,
        i = 0, j = 0
  
    while (i < aLen && j < bLen) {
      aVal = a[i], bVal = b[j]
      if (aVal < bVal) {
        i += 2
      } else if (aVal > bVal) {
        j += 2
      } else if (aVal == bVal) {
        dotProduct += a[i + 1] * b[j + 1]
        i += 2
        j += 2
      }
    }
  
    return dotProduct
  }
  
  /**
   * Calculates the cosine similarity between this vector and another
   * vector.
   *
   * @param {lunr.Vector} otherVector - The other vector to calculate the
   * similarity with.
   * @returns {Number}
   */
  lunr.Vector.prototype.similarity = function (otherVector) {
    return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude())
  }
  
  /**
   * Converts the vector to an array of the elements within the vector.
   *
   * @returns {Number[]}
   */
  lunr.Vector.prototype.toArray = function () {
    var output = new Array (this.elements.length / 2)
  
    for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {
      output[j] = this.elements[i]
    }
  
    return output
  }
  
  /**
   * A JSON serializable representation of the vector.
   *
   * @returns {Number[]}
   */
  lunr.Vector.prototype.toJSON = function () {
    return this.elements
  }
  /* eslint-disable */
  /*!
   * lunr.stemmer
   * Copyright (C) 2017 Oliver Nightingale
   * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
   */
  
  /**
   * lunr.stemmer is an english language stemmer, this is a JavaScript
   * implementation of the PorterStemmer taken from http://tartarus.org/~martin
   *
   * @static
   * @implements {lunr.PipelineFunction}
   * @param {lunr.Token} token - The string to stem
   * @returns {lunr.Token}
   * @see {@link lunr.Pipeline}
   */
  lunr.stemmer = (function(){
    var step2list = {
        "ational" : "ate",
        "tional" : "tion",
        "enci" : "ence",
        "anci" : "ance",
        "izer" : "ize",
        "bli" : "ble",
        "alli" : "al",
        "entli" : "ent",
        "eli" : "e",
        "ousli" : "ous",
        "ization" : "ize",
        "ation" : "ate",
        "ator" : "ate",
        "alism" : "al",
        "iveness" : "ive",
        "fulness" : "ful",
        "ousness" : "ous",
        "aliti" : "al",
        "iviti" : "ive",
        "biliti" : "ble",
        "logi" : "log"
      },
  
      step3list = {
        "icate" : "ic",
        "ative" : "",
        "alize" : "al",
        "iciti" : "ic",
        "ical" : "ic",
        "ful" : "",
        "ness" : ""
      },
  
      c = "[^aeiou]",          // consonant
      v = "[aeiouy]",          // vowel
      C = c + "[^aeiouy]*",    // consonant sequence
      V = v + "[aeiou]*",      // vowel sequence
  
      mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
      meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
      mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
      s_v = "^(" + C + ")?" + v;                   // vowel in stem
  
    var re_mgr0 = new RegExp(mgr0);
    var re_mgr1 = new RegExp(mgr1);
    var re_meq1 = new RegExp(meq1);
    var re_s_v = new RegExp(s_v);
  
    var re_1a = /^(.+?)(ss|i)es$/;
    var re2_1a = /^(.+?)([^s])s$/;
    var re_1b = /^(.+?)eed$/;
    var re2_1b = /^(.+?)(ed|ing)$/;
    var re_1b_2 = /.$/;
    var re2_1b_2 = /(at|bl|iz)$/;
    var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
    var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");
  
    var re_1c = /^(.+?[^aeiou])y$/;
    var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
  
    var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
  
    var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    var re2_4 = /^(.+?)(s|t)(ion)$/;
  
    var re_5 = /^(.+?)e$/;
    var re_5_1 = /ll$/;
    var re3_5 = new RegExp("^" + C + v + "[^aeiouwxy]$");
  
    var porterStemmer = function porterStemmer(w) {
      var stem,
        suffix,
        firstch,
        re,
        re2,
        re3,
        re4;
  
      if (w.length < 3) { return w; }
  
      firstch = w.substr(0,1);
      if (firstch == "y") {
        w = firstch.toUpperCase() + w.substr(1);
      }
  
      // Step 1a
      re = re_1a
      re2 = re2_1a;
  
      if (re.test(w)) { w = w.replace(re,"$1$2"); }
      else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }
  
      // Step 1b
      re = re_1b;
      re2 = re2_1b;
      if (re.test(w)) {
        var fp = re.exec(w);
        re = re_mgr0;
        if (re.test(fp[1])) {
          re = re_1b_2;
          w = w.replace(re,"");
        }
      } else if (re2.test(w)) {
        var fp = re2.exec(w);
        stem = fp[1];
        re2 = re_s_v;
        if (re2.test(stem)) {
          w = stem;
          re2 = re2_1b_2;
          re3 = re3_1b_2;
          re4 = re4_1b_2;
          if (re2.test(w)) { w = w + "e"; }
          else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,""); }
          else if (re4.test(w)) { w = w + "e"; }
        }
      }
  
      // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)
      re = re_1c;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        w = stem + "i";
      }
  
      // Step 2
      re = re_2;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        suffix = fp[2];
        re = re_mgr0;
        if (re.test(stem)) {
          w = stem + step2list[suffix];
        }
      }
  
      // Step 3
      re = re_3;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        suffix = fp[2];
        re = re_mgr0;
        if (re.test(stem)) {
          w = stem + step3list[suffix];
        }
      }
  
      // Step 4
      re = re_4;
      re2 = re2_4;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        re = re_mgr1;
        if (re.test(stem)) {
          w = stem;
        }
      } else if (re2.test(w)) {
        var fp = re2.exec(w);
        stem = fp[1] + fp[2];
        re2 = re_mgr1;
        if (re2.test(stem)) {
          w = stem;
        }
      }
  
      // Step 5
      re = re_5;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        re = re_mgr1;
        re2 = re_meq1;
        re3 = re3_5;
        if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
          w = stem;
        }
      }
  
      re = re_5_1;
      re2 = re_mgr1;
      if (re.test(w) && re2.test(w)) {
        re = re_1b_2;
        w = w.replace(re,"");
      }
  
      // and turn initial Y back to y
  
      if (firstch == "y") {
        w = firstch.toLowerCase() + w.substr(1);
      }
  
      return w;
    };
  
    return function (token) {
      return token.update(porterStemmer);
    }
  })();
  
  lunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer')
  /*!
   * lunr.stopWordFilter
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * lunr.generateStopWordFilter builds a stopWordFilter function from the provided
   * list of stop words.
   *
   * The built in lunr.stopWordFilter is built using this generator and can be used
   * to generate custom stopWordFilters for applications or non English languages.
   *
   * @param {Array} token The token to pass through the filter
   * @returns {lunr.PipelineFunction}
   * @see lunr.Pipeline
   * @see lunr.stopWordFilter
   */
  lunr.generateStopWordFilter = function (stopWords) {
    var words = stopWords.reduce(function (memo, stopWord) {
      memo[stopWord] = stopWord
      return memo
    }, {})
  
    return function (token) {
      if (token && words[token.toString()] !== token.toString()) return token
    }
  }
  
  /**
   * lunr.stopWordFilter is an English language stop word list filter, any words
   * contained in the list will not be passed through the filter.
   *
   * This is intended to be used in the Pipeline. If the token does not pass the
   * filter then undefined will be returned.
   *
   * @implements {lunr.PipelineFunction}
   * @params {lunr.Token} token - A token to check for being a stop word.
   * @returns {lunr.Token}
   * @see {@link lunr.Pipeline}
   */
  lunr.stopWordFilter = lunr.generateStopWordFilter([
    'a',
    'able',
    'about',
    'across',
    'after',
    'all',
    'almost',
    'also',
    'am',
    'among',
    'an',
    'and',
    'any',
    'are',
    'as',
    'at',
    'be',
    'because',
    'been',
    'but',
    'by',
    'can',
    'cannot',
    'could',
    'dear',
    'did',
    'do',
    'does',
    'either',
    'else',
    'ever',
    'every',
    'for',
    'from',
    'get',
    'got',
    'had',
    'has',
    'have',
    'he',
    'her',
    'hers',
    'him',
    'his',
    'how',
    'however',
    'i',
    'if',
    'in',
    'into',
    'is',
    'it',
    'its',
    'just',
    'least',
    'let',
    'like',
    'likely',
    'may',
    'me',
    'might',
    'most',
    'must',
    'my',
    'neither',
    'no',
    'nor',
    'not',
    'of',
    'off',
    'often',
    'on',
    'only',
    'or',
    'other',
    'our',
    'own',
    'rather',
    'said',
    'say',
    'says',
    'she',
    'should',
    'since',
    'so',
    'some',
    'than',
    'that',
    'the',
    'their',
    'them',
    'then',
    'there',
    'these',
    'they',
    'this',
    'tis',
    'to',
    'too',
    'twas',
    'us',
    'wants',
    'was',
    'we',
    'were',
    'what',
    'when',
    'where',
    'which',
    'while',
    'who',
    'whom',
    'why',
    'will',
    'with',
    'would',
    'yet',
    'you',
    'your'
  ])
  
  lunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter')
  /*!
   * lunr.trimmer
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * lunr.trimmer is a pipeline function for trimming non word
   * characters from the beginning and end of tokens before they
   * enter the index.
   *
   * This implementation may not work correctly for non latin
   * characters and should either be removed or adapted for use
   * with languages with non-latin characters.
   *
   * @static
   * @implements {lunr.PipelineFunction}
   * @param {lunr.Token} token The token to pass through the filter
   * @returns {lunr.Token}
   * @see lunr.Pipeline
   */
  lunr.trimmer = function (token) {
    return token.update(function (s) {
      return s.replace(/^\W+/, '').replace(/\W+$/, '')
    })
  }
  
  lunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer')
  /*!
   * lunr.TokenSet
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * A token set is used to store the unique list of all tokens
   * within an index. Token sets are also used to represent an
   * incoming query to the index, this query token set and index
   * token set are then intersected to find which tokens to look
   * up in the inverted index.
   *
   * A token set can hold multiple tokens, as in the case of the
   * index token set, or it can hold a single token as in the
   * case of a simple query token set.
   *
   * Additionally token sets are used to perform wildcard matching.
   * Leading, contained and trailing wildcards are supported, and
   * from this edit distance matching can also be provided.
   *
   * Token sets are implemented as a minimal finite state automata,
   * where both common prefixes and suffixes are shared between tokens.
   * This helps to reduce the space used for storing the token set.
   *
   * @constructor
   */
  lunr.TokenSet = function () {
    this.final = false
    this.edges = {}
    this.id = lunr.TokenSet._nextId
    lunr.TokenSet._nextId += 1
  }
  
  /**
   * Keeps track of the next, auto increment, identifier to assign
   * to a new tokenSet.
   *
   * TokenSets require a unique identifier to be correctly minimised.
   *
   * @private
   */
  lunr.TokenSet._nextId = 1
  
  /**
   * Creates a TokenSet instance from the given sorted array of words.
   *
   * @param {String[]} arr - A sorted array of strings to create the set from.
   * @returns {lunr.TokenSet}
   * @throws Will throw an error if the input array is not sorted.
   */
  lunr.TokenSet.fromArray = function (arr) {
    var builder = new lunr.TokenSet.Builder
  
    for (var i = 0, len = arr.length; i < len; i++) {
      builder.insert(arr[i])
    }
  
    builder.finish()
    return builder.root
  }
  
  /**
   * Creates a token set from a query clause.
   *
   * @private
   * @param {Object} clause - A single clause from lunr.Query.
   * @param {string} clause.term - The query clause term.
   * @param {number} [clause.editDistance] - The optional edit distance for the term.
   * @returns {lunr.TokenSet}
   */
  lunr.TokenSet.fromClause = function (clause) {
    if ('editDistance' in clause) {
      return lunr.TokenSet.fromFuzzyString(clause.term, clause.editDistance)
    } else {
      return lunr.TokenSet.fromString(clause.term)
    }
  }
  
  /**
   * Creates a token set representing a single string with a specified
   * edit distance.
   *
   * Insertions, deletions, substitutions and transpositions are each
   * treated as an edit distance of 1.
   *
   * Increasing the allowed edit distance will have a dramatic impact
   * on the performance of both creating and intersecting these TokenSets.
   * It is advised to keep the edit distance less than 3.
   *
   * @param {string} str - The string to create the token set from.
   * @param {number} editDistance - The allowed edit distance to match.
   * @returns {lunr.Vector}
   */
  lunr.TokenSet.fromFuzzyString = function (str, editDistance) {
    var root = new lunr.TokenSet
  
    var stack = [{
      node: root,
      editsRemaining: editDistance,
      str: str
    }]
  
    while (stack.length) {
      var frame = stack.pop()
  
      // no edit
      if (frame.str.length > 0) {
        var char = frame.str.charAt(0),
            noEditNode
  
        if (char in frame.node.edges) {
          noEditNode = frame.node.edges[char]
        } else {
          noEditNode = new lunr.TokenSet
          frame.node.edges[char] = noEditNode
        }
  
        if (frame.str.length == 1) {
          noEditNode.final = true
        } else {
          stack.push({
            node: noEditNode,
            editsRemaining: frame.editsRemaining,
            str: frame.str.slice(1)
          })
        }
      }
  
      // deletion
      // can only do a deletion if we have enough edits remaining
      // and if there are characters left to delete in the string
      if (frame.editsRemaining > 0 && frame.str.length > 1) {
        var char = frame.str.charAt(1),
            deletionNode
  
        if (char in frame.node.edges) {
          deletionNode = frame.node.edges[char]
        } else {
          deletionNode = new lunr.TokenSet
          frame.node.edges[char] = deletionNode
        }
  
        if (frame.str.length <= 2) {
          deletionNode.final = true
        } else {
          stack.push({
            node: deletionNode,
            editsRemaining: frame.editsRemaining - 1,
            str: frame.str.slice(2)
          })
        }
      }
  
      // deletion
      // just removing the last character from the str
      if (frame.editsRemaining > 0 && frame.str.length == 1) {
        frame.node.final = true
      }
  
      // substitution
      // can only do a substitution if we have enough edits remaining
      // and if there are characters left to substitute
      if (frame.editsRemaining > 0 && frame.str.length >= 1) {
        if ("*" in frame.node.edges) {
          var substitutionNode = frame.node.edges["*"]
        } else {
          var substitutionNode = new lunr.TokenSet
          frame.node.edges["*"] = substitutionNode
        }
  
        if (frame.str.length == 1) {
          substitutionNode.final = true
        } else {
          stack.push({
            node: substitutionNode,
            editsRemaining: frame.editsRemaining - 1,
            str: frame.str.slice(1)
          })
        }
      }
  
      // insertion
      // can only do insertion if there are edits remaining
      if (frame.editsRemaining > 0) {
        if ("*" in frame.node.edges) {
          var insertionNode = frame.node.edges["*"]
        } else {
          var insertionNode = new lunr.TokenSet
          frame.node.edges["*"] = insertionNode
        }
  
        if (frame.str.length == 0) {
          insertionNode.final = true
        } else {
          stack.push({
            node: insertionNode,
            editsRemaining: frame.editsRemaining - 1,
            str: frame.str
          })
        }
      }
  
      // transposition
      // can only do a transposition if there are edits remaining
      // and there are enough characters to transpose
      if (frame.editsRemaining > 0 && frame.str.length > 1) {
        var charA = frame.str.charAt(0),
            charB = frame.str.charAt(1),
            transposeNode
  
        if (charB in frame.node.edges) {
          transposeNode = frame.node.edges[charB]
        } else {
          transposeNode = new lunr.TokenSet
          frame.node.edges[charB] = transposeNode
        }
  
        if (frame.str.length == 1) {
          transposeNode.final = true
        } else {
          stack.push({
            node: transposeNode,
            editsRemaining: frame.editsRemaining - 1,
            str: charA + frame.str.slice(2)
          })
        }
      }
    }
  
    return root
  }
  
  /**
   * Creates a TokenSet from a string.
   *
   * The string may contain one or more wildcard characters (*)
   * that will allow wildcard matching when intersecting with
   * another TokenSet.
   *
   * @param {string} str - The string to create a TokenSet from.
   * @returns {lunr.TokenSet}
   */
  lunr.TokenSet.fromString = function (str) {
    var node = new lunr.TokenSet,
        root = node,
        wildcardFound = false
  
    /*
     * Iterates through all characters within the passed string
     * appending a node for each character.
     *
     * As soon as a wildcard character is found then a self
     * referencing edge is introduced to continually match
     * any number of any characters.
     */
    for (var i = 0, len = str.length; i < len; i++) {
      var char = str[i],
          final = (i == len - 1)
  
      if (char == "*") {
        wildcardFound = true
        node.edges[char] = node
        node.final = final
  
      } else {
        var next = new lunr.TokenSet
        next.final = final
  
        node.edges[char] = next
        node = next
  
        // TODO: is this needed anymore?
        if (wildcardFound) {
          node.edges["*"] = root
        }
      }
    }
  
    return root
  }
  
  /**
   * Converts this TokenSet into an array of strings
   * contained within the TokenSet.
   *
   * @returns {string[]}
   */
  lunr.TokenSet.prototype.toArray = function () {
    var words = []
  
    var stack = [{
      prefix: "",
      node: this
    }]
  
    while (stack.length) {
      var frame = stack.pop(),
          edges = Object.keys(frame.node.edges),
          len = edges.length
  
      if (frame.node.final) {
        words.push(frame.prefix)
      }
  
      for (var i = 0; i < len; i++) {
        var edge = edges[i]
  
        stack.push({
          prefix: frame.prefix.concat(edge),
          node: frame.node.edges[edge]
        })
      }
    }
  
    return words
  }
  
  /**
   * Generates a string representation of a TokenSet.
   *
   * This is intended to allow TokenSets to be used as keys
   * in objects, largely to aid the construction and minimisation
   * of a TokenSet. As such it is not designed to be a human
   * friendly representation of the TokenSet.
   *
   * @returns {string}
   */
  lunr.TokenSet.prototype.toString = function () {
    // NOTE: Using Object.keys here as this.edges is very likely
    // to enter 'hash-mode' with many keys being added
    //
    // avoiding a for-in loop here as it leads to the function
    // being de-optimised (at least in V8). From some simple
    // benchmarks the performance is comparable, but allowing
    // V8 to optimize may mean easy performance wins in the future.
  
    if (this._str) {
      return this._str
    }
  
    var str = this.final ? '1' : '0',
        labels = Object.keys(this.edges).sort(),
        len = labels.length
  
    for (var i = 0; i < len; i++) {
      var label = labels[i],
          node = this.edges[label]
  
      str = str + label + node.id
    }
  
    return str
  }
  
  /**
   * Returns a new TokenSet that is the intersection of
   * this TokenSet and the passed TokenSet.
   *
   * This intersection will take into account any wildcards
   * contained within the TokenSet.
   *
   * @param {lunr.TokenSet} b - An other TokenSet to intersect with.
   * @returns {lunr.TokenSet}
   */
  lunr.TokenSet.prototype.intersect = function (b) {
    var output = new lunr.TokenSet,
        frame = undefined
  
    var stack = [{
      qNode: b,
      output: output,
      node: this
    }]
  
    while (stack.length) {
      frame = stack.pop()
  
      // NOTE: As with the #toString method, we are using
      // Object.keys and a for loop instead of a for-in loop
      // as both of these objects enter 'hash' mode, causing
      // the function to be de-optimised in V8
      var qEdges = Object.keys(frame.qNode.edges),
          qLen = qEdges.length,
          nEdges = Object.keys(frame.node.edges),
          nLen = nEdges.length
  
      for (var q = 0; q < qLen; q++) {
        var qEdge = qEdges[q]
  
        for (var n = 0; n < nLen; n++) {
          var nEdge = nEdges[n]
  
          if (nEdge == qEdge || qEdge == '*') {
            var node = frame.node.edges[nEdge],
                qNode = frame.qNode.edges[qEdge],
                final = node.final && qNode.final,
                next = undefined
  
            if (nEdge in frame.output.edges) {
              // an edge already exists for this character
              // no need to create a new node, just set the finality
              // bit unless this node is already final
              next = frame.output.edges[nEdge]
              next.final = next.final || final
  
            } else {
              // no edge exists yet, must create one
              // set the finality bit and insert it
              // into the output
              next = new lunr.TokenSet
              next.final = final
              frame.output.edges[nEdge] = next
            }
  
            stack.push({
              qNode: qNode,
              output: next,
              node: node
            })
          }
        }
      }
    }
  
    return output
  }
  lunr.TokenSet.Builder = function () {
    this.previousWord = ""
    this.root = new lunr.TokenSet
    this.uncheckedNodes = []
    this.minimizedNodes = {}
  }
  
  lunr.TokenSet.Builder.prototype.insert = function (word) {
    var node,
        commonPrefix = 0
  
    if (word < this.previousWord) {
      throw new Error ("Out of order word insertion")
    }
  
    for (var i = 0; i < word.length && i < this.previousWord.length; i++) {
      if (word[i] != this.previousWord[i]) break
      commonPrefix++
    }
  
    this.minimize(commonPrefix)
  
    if (this.uncheckedNodes.length == 0) {
      node = this.root
    } else {
      node = this.uncheckedNodes[this.uncheckedNodes.length - 1].child
    }
  
    for (var i = commonPrefix; i < word.length; i++) {
      var nextNode = new lunr.TokenSet,
          char = word[i]
  
      node.edges[char] = nextNode
  
      this.uncheckedNodes.push({
        parent: node,
        char: char,
        child: nextNode
      })
  
      node = nextNode
    }
  
    node.final = true
    this.previousWord = word
  }
  
  lunr.TokenSet.Builder.prototype.finish = function () {
    this.minimize(0)
  }
  
  lunr.TokenSet.Builder.prototype.minimize = function (downTo) {
    for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {
      var node = this.uncheckedNodes[i],
          childKey = node.child.toString()
  
      if (childKey in this.minimizedNodes) {
        node.parent.edges[node.char] = this.minimizedNodes[childKey]
      } else {
        // Cache the key for this node since
        // we know it can't change anymore
        node.child._str = childKey
  
        this.minimizedNodes[childKey] = node.child
      }
  
      this.uncheckedNodes.pop()
    }
  }
  /*!
   * lunr.Index
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * An index contains the built index of all documents and provides a query interface
   * to the index.
   *
   * Usually instances of lunr.Index will not be created using this constructor, instead
   * lunr.Builder should be used to construct new indexes, or lunr.Index.load should be
   * used to load previously built and serialized indexes.
   *
   * @constructor
   * @param {Object} attrs - The attributes of the built search index.
   * @param {Object} attrs.invertedIndex - An index of term/field to document reference.
   * @param {Object<string, lunr.Vector>} attrs.documentVectors - Document vectors keyed by document reference.
   * @param {lunr.TokenSet} attrs.tokenSet - An set of all corpus tokens.
   * @param {string[]} attrs.fields - The names of indexed document fields.
   * @param {lunr.Pipeline} attrs.pipeline - The pipeline to use for search terms.
   */
  lunr.Index = function (attrs) {
    this.invertedIndex = attrs.invertedIndex
    this.fieldVectors = attrs.fieldVectors
    this.tokenSet = attrs.tokenSet
    this.fields = attrs.fields
    this.pipeline = attrs.pipeline
  }
  
  /**
   * A result contains details of a document matching a search query.
   * @typedef {Object} lunr.Index~Result
   * @property {string} ref - The reference of the document this result represents.
   * @property {number} score - A number between 0 and 1 representing how similar this document is to the query.
   * @property {lunr.MatchData} matchData - Contains metadata about this match including which term(s) caused the match.
   */
  
  /**
   * Although lunr provides the ability to create queries using lunr.Query, it also provides a simple
   * query language which itself is parsed into an instance of lunr.Query.
   *
   * For programmatically building queries it is advised to directly use lunr.Query, the query language
   * is best used for human entered text rather than program generated text.
   *
   * At its simplest queries can just be a single term, e.g. `hello`, multiple terms are also supported
   * and will be combined with OR, e.g `hello world` will match documents that contain either 'hello'
   * or 'world', though those that contain both will rank higher in the results.
   *
   * Wildcards can be included in terms to match one or more unspecified characters, these wildcards can
   * be inserted anywhere within the term, and more than one wildcard can exist in a single term. Adding
   * wildcards will increase the number of documents that will be found but can also have a negative
   * impact on query performance, especially with wildcards at the beginning of a term.
   *
   * Terms can be restricted to specific fields, e.g. `title:hello`, only documents with the term
   * hello in the title field will match this query. Using a field not present in the index will lead
   * to an error being thrown.
   *
   * Modifiers can also be added to terms, lunr supports edit distance and boost modifiers on terms. A term
   * boost will make documents matching that term score higher, e.g. `foo^5`. Edit distance is also supported
   * to provide fuzzy matching, e.g. 'hello~2' will match documents with hello with an edit distance of 2.
   * Avoid large values for edit distance to improve query performance.
   *
   * To escape special characters the backslash character '\' can be used, this allows searches to include
   * characters that would normally be considered modifiers, e.g. `foo\~2` will search for a term "foo~2" instead
   * of attempting to apply a boost of 2 to the search term "foo".
   *
   * @typedef {string} lunr.Index~QueryString
   * @example <caption>Simple single term query</caption>
   * hello
   * @example <caption>Multiple term query</caption>
   * hello world
   * @example <caption>term scoped to a field</caption>
   * title:hello
   * @example <caption>term with a boost of 10</caption>
   * hello^10
   * @example <caption>term with an edit distance of 2</caption>
   * hello~2
   */
  
  /**
   * Performs a search against the index using lunr query syntax.
   *
   * Results will be returned sorted by their score, the most relevant results
   * will be returned first.
   *
   * For more programmatic querying use lunr.Index#query.
   *
   * @param {lunr.Index~QueryString} queryString - A string containing a lunr query.
   * @throws {lunr.QueryParseError} If the passed query string cannot be parsed.
   * @returns {lunr.Index~Result[]}
   */
  lunr.Index.prototype.search = function (queryString) {
    return this.query(function (query) {
      var parser = new lunr.QueryParser(queryString, query)
      parser.parse()
    })
  }
  
  /**
   * A query builder callback provides a query object to be used to express
   * the query to perform on the index.
   *
   * @callback lunr.Index~queryBuilder
   * @param {lunr.Query} query - The query object to build up.
   * @this lunr.Query
   */
  
  /**
   * Performs a query against the index using the yielded lunr.Query object.
   *
   * If performing programmatic queries against the index, this method is preferred
   * over lunr.Index#search so as to avoid the additional query parsing overhead.
   *
   * A query object is yielded to the supplied function which should be used to
   * express the query to be run against the index.
   *
   * Note that although this function takes a callback parameter it is _not_ an
   * asynchronous operation, the callback is just yielded a query object to be
   * customized.
   *
   * @param {lunr.Index~queryBuilder} fn - A function that is used to build the query.
   * @returns {lunr.Index~Result[]}
   */
  lunr.Index.prototype.query = function (fn) {
    // for each query clause
    // * process terms
    // * expand terms from token set
    // * find matching documents and metadata
    // * get document vectors
    // * score documents
  
    var query = new lunr.Query(this.fields),
        matchingFields = Object.create(null),
        queryVectors = Object.create(null)
  
    fn.call(query, query)
  
    for (var i = 0; i < query.clauses.length; i++) {
      /*
       * Unless the pipeline has been disabled for this term, which is
       * the case for terms with wildcards, we need to pass the clause
       * term through the search pipeline. A pipeline returns an array
       * of processed terms. Pipeline functions may expand the passed
       * term, which means we may end up performing multiple index lookups
       * for a single query term.
       */
      var clause = query.clauses[i],
          terms = null
  
      if (clause.usePipeline) {
        terms = this.pipeline.runString(clause.term)
      } else {
        terms = [clause.term]
      }
  
      for (var m = 0; m < terms.length; m++) {
        var term = terms[m]
  
        /*
         * Each term returned from the pipeline needs to use the same query
         * clause object, e.g. the same boost and or edit distance. The
         * simplest way to do this is to re-use the clause object but mutate
         * its term property.
         */
        clause.term = term
  
        /*
         * From the term in the clause we create a token set which will then
         * be used to intersect the indexes token set to get a list of terms
         * to lookup in the inverted index
         */
        var termTokenSet = lunr.TokenSet.fromClause(clause),
            expandedTerms = this.tokenSet.intersect(termTokenSet).toArray()
  
        for (var j = 0; j < expandedTerms.length; j++) {
          /*
           * For each term get the posting and termIndex, this is required for
           * building the query vector.
           */
          var expandedTerm = expandedTerms[j],
              posting = this.invertedIndex[expandedTerm],
              termIndex = posting._index
  
          for (var k = 0; k < clause.fields.length; k++) {
            /*
             * For each field that this query term is scoped by (by default
             * all fields are in scope) we need to get all the document refs
             * that have this term in that field.
             *
             * The posting is the entry in the invertedIndex for the matching
             * term from above.
             */
            var field = clause.fields[k],
                fieldPosting = posting[field],
                matchingDocumentRefs = Object.keys(fieldPosting)
  
            /*
             * To support field level boosts a query vector is created per
             * field. This vector is populated using the termIndex found for
             * the term and a unit value with the appropriate boost applied.
             *
             * If the query vector for this field does not exist yet it needs
             * to be created.
             */
            if (!(field in queryVectors)) {
              queryVectors[field] = new lunr.Vector
            }
  
            /*
             * Using upsert because there could already be an entry in the vector
             * for the term we are working with. In that case we just add the scores
             * together.
             */
            queryVectors[field].upsert(termIndex, 1 * clause.boost, function (a, b) { return a + b })
  
            for (var l = 0; l < matchingDocumentRefs.length; l++) {
              /*
               * All metadata for this term/field/document triple
               * are then extracted and collected into an instance
               * of lunr.MatchData ready to be returned in the query
               * results
               */
              var matchingDocumentRef = matchingDocumentRefs[l],
                  matchingFieldRef = new lunr.FieldRef (matchingDocumentRef, field),
                  documentMetadata, matchData
  
              documentMetadata = fieldPosting[matchingDocumentRef]
              matchData = new lunr.MatchData (expandedTerm, field, documentMetadata)
  
              if (matchingFieldRef in matchingFields) {
                matchingFields[matchingFieldRef].combine(matchData)
              } else {
                matchingFields[matchingFieldRef] = matchData
              }
  
            }
          }
        }
      }
    }
  
    var matchingFieldRefs = Object.keys(matchingFields),
        results = {}
  
    for (var i = 0; i < matchingFieldRefs.length; i++) {
      /*
       * Currently we have document fields that match the query, but we
       * need to return documents. The matchData and scores are combined
       * from multiple fields belonging to the same document.
       *
       * Scores are calculated by field, using the query vectors created
       * above, and combined into a final document score using addition.
       */
      var fieldRef = lunr.FieldRef.fromString(matchingFieldRefs[i]),
          docRef = fieldRef.docRef,
          fieldVector = this.fieldVectors[fieldRef],
          score = queryVectors[fieldRef.fieldName].similarity(fieldVector)
  
      if (docRef in results) {
        results[docRef].score += score
        results[docRef].matchData.combine(matchingFields[fieldRef])
      } else {
        results[docRef] = {
          ref: docRef,
          score: score,
          matchData: matchingFields[fieldRef]
        }
      }
    }
  
    /*
     * The results object needs to be converted into a list
     * of results, sorted by score before being returned.
     */
    return Object.keys(results)
      .map(function (key) {
        return results[key]
      })
      .sort(function (a, b) {
        return b.score - a.score
      })
  }
  
  /**
   * Prepares the index for JSON serialization.
   *
   * The schema for this JSON blob will be described in a
   * separate JSON schema file.
   *
   * @returns {Object}
   */
  lunr.Index.prototype.toJSON = function () {
    var invertedIndex = Object.keys(this.invertedIndex)
      .sort()
      .map(function (term) {
        return [term, this.invertedIndex[term]]
      }, this)
  
    var fieldVectors = Object.keys(this.fieldVectors)
      .map(function (ref) {
        return [ref, this.fieldVectors[ref].toJSON()]
      }, this)
  
    return {
      version: lunr.version,
      fields: this.fields,
      fieldVectors: fieldVectors,
      invertedIndex: invertedIndex,
      pipeline: this.pipeline.toJSON()
    }
  }
  
  /**
   * Loads a previously serialized lunr.Index
   *
   * @param {Object} serializedIndex - A previously serialized lunr.Index
   * @returns {lunr.Index}
   */
  lunr.Index.load = function (serializedIndex) {
    var attrs = {},
        fieldVectors = {},
        serializedVectors = serializedIndex.fieldVectors,
        invertedIndex = {},
        serializedInvertedIndex = serializedIndex.invertedIndex,
        tokenSetBuilder = new lunr.TokenSet.Builder,
        pipeline = lunr.Pipeline.load(serializedIndex.pipeline)
  
    if (serializedIndex.version != lunr.version) {
      lunr.utils.warn("Version mismatch when loading serialised index. Current version of lunr '" + lunr.version + "' does not match serialized index '" + serializedIndex.version + "'")
    }
  
    for (var i = 0; i < serializedVectors.length; i++) {
      var tuple = serializedVectors[i],
          ref = tuple[0],
          elements = tuple[1]
  
      fieldVectors[ref] = new lunr.Vector(elements)
    }
  
    for (var i = 0; i < serializedInvertedIndex.length; i++) {
      var tuple = serializedInvertedIndex[i],
          term = tuple[0],
          posting = tuple[1]
  
      tokenSetBuilder.insert(term)
      invertedIndex[term] = posting
    }
  
    tokenSetBuilder.finish()
  
    attrs.fields = serializedIndex.fields
  
    attrs.fieldVectors = fieldVectors
    attrs.invertedIndex = invertedIndex
    attrs.tokenSet = tokenSetBuilder.root
    attrs.pipeline = pipeline
  
    return new lunr.Index(attrs)
  }
  /*!
   * lunr.Builder
   * Copyright (C) 2017 Oliver Nightingale
   */
  
  /**
   * lunr.Builder performs indexing on a set of documents and
   * returns instances of lunr.Index ready for querying.
   *
   * All configuration of the index is done via the builder, the
   * fields to index, the document reference, the text processing
   * pipeline and document scoring parameters are all set on the
   * builder before indexing.
   *
   * @constructor
   * @property {string} _ref - Internal reference to the document reference field.
   * @property {string[]} _fields - Internal reference to the document fields to index.
   * @property {object} invertedIndex - The inverted index maps terms to document fields.
   * @property {object} documentTermFrequencies - Keeps track of document term frequencies.
   * @property {object} documentLengths - Keeps track of the length of documents added to the index.
   * @property {lunr.tokenizer} tokenizer - Function for splitting strings into tokens for indexing.
   * @property {lunr.Pipeline} pipeline - The pipeline performs text processing on tokens before indexing.
   * @property {lunr.Pipeline} searchPipeline - A pipeline for processing search terms before querying the index.
   * @property {number} documentCount - Keeps track of the total number of documents indexed.
   * @property {number} _b - A parameter to control field length normalization, setting this to 0 disabled normalization, 1 fully normalizes field lengths, the default value is 0.75.
   * @property {number} _k1 - A parameter to control how quickly an increase in term frequency results in term frequency saturation, the default value is 1.2.
   * @property {number} termIndex - A counter incremented for each unique term, used to identify a terms position in the vector space.
   * @property {array} metadataWhitelist - A list of metadata keys that have been whitelisted for entry in the index.
   */
  lunr.Builder = function () {
    this._ref = "id"
    this._fields = []
    this.invertedIndex = Object.create(null)
    this.fieldTermFrequencies = {}
    this.fieldLengths = {}
    this.tokenizer = lunr.tokenizer
    this.pipeline = new lunr.Pipeline
    this.searchPipeline = new lunr.Pipeline
    this.documentCount = 0
    this._b = 0.75
    this._k1 = 1.2
    this.termIndex = 0
    this.metadataWhitelist = []
  }
  
  /**
   * Sets the document field used as the document reference. Every document must have this field.
   * The type of this field in the document should be a string, if it is not a string it will be
   * coerced into a string by calling toString.
   *
   * The default ref is 'id'.
   *
   * The ref should _not_ be changed during indexing, it should be set before any documents are
   * added to the index. Changing it during indexing can lead to inconsistent results.
   *
   * @param {string} ref - The name of the reference field in the document.
   */
  lunr.Builder.prototype.ref = function (ref) {
    this._ref = ref
  }
  
  /**
   * Adds a field to the list of document fields that will be indexed. Every document being
   * indexed should have this field. Null values for this field in indexed documents will
   * not cause errors but will limit the chance of that document being retrieved by searches.
   *
   * All fields should be added before adding documents to the index. Adding fields after
   * a document has been indexed will have no effect on already indexed documents.
   *
   * @param {string} field - The name of a field to index in all documents.
   */
  lunr.Builder.prototype.field = function (field) {
    this._fields.push(field)
  }
  
  /**
   * A parameter to tune the amount of field length normalisation that is applied when
   * calculating relevance scores. A value of 0 will completely disable any normalisation
   * and a value of 1 will fully normalise field lengths. The default is 0.75. Values of b
   * will be clamped to the range 0 - 1.
   *
   * @param {number} number - The value to set for this tuning parameter.
   */
  lunr.Builder.prototype.b = function (number) {
    if (number < 0) {
      this._b = 0
    } else if (number > 1) {
      this._b = 1
    } else {
      this._b = number
    }
  }
  
  /**
   * A parameter that controls the speed at which a rise in term frequency results in term
   * frequency saturation. The default value is 1.2. Setting this to a higher value will give
   * slower saturation levels, a lower value will result in quicker saturation.
   *
   * @param {number} number - The value to set for this tuning parameter.
   */
  lunr.Builder.prototype.k1 = function (number) {
    this._k1 = number
  }
  
  /**
   * Adds a document to the index.
   *
   * Before adding fields to the index the index should have been fully setup, with the document
   * ref and all fields to index already having been specified.
   *
   * The document must have a field name as specified by the ref (by default this is 'id') and
   * it should have all fields defined for indexing, though null or undefined values will not
   * cause errors.
   *
   * @param {object} doc - The document to add to the index.
   */
  lunr.Builder.prototype.add = function (doc) {
    var docRef = doc[this._ref]
  
    this.documentCount += 1
  
    for (var i = 0; i < this._fields.length; i++) {
      var fieldName = this._fields[i],
          field = doc[fieldName],
          tokens = this.tokenizer(field),
          terms = this.pipeline.run(tokens),
          fieldRef = new lunr.FieldRef (docRef, fieldName),
          fieldTerms = Object.create(null)
  
      this.fieldTermFrequencies[fieldRef] = fieldTerms
      this.fieldLengths[fieldRef] = 0
  
      // store the length of this field for this document
      this.fieldLengths[fieldRef] += terms.length
  
      // calculate term frequencies for this field
      for (var j = 0; j < terms.length; j++) {
        var term = terms[j]
  
        if (fieldTerms[term] == undefined) {
          fieldTerms[term] = 0
        }
  
        fieldTerms[term] += 1
  
        // add to inverted index
        // create an initial posting if one doesn't exist
        if (this.invertedIndex[term] == undefined) {
          var posting = Object.create(null)
          posting["_index"] = this.termIndex
          this.termIndex += 1
  
          for (var k = 0; k < this._fields.length; k++) {
            posting[this._fields[k]] = Object.create(null)
          }
  
          this.invertedIndex[term] = posting
        }
  
        // add an entry for this term/fieldName/docRef to the invertedIndex
        if (this.invertedIndex[term][fieldName][docRef] == undefined) {
          this.invertedIndex[term][fieldName][docRef] = Object.create(null)
        }
  
        // store all whitelisted metadata about this token in the
        // inverted index
        for (var l = 0; l < this.metadataWhitelist.length; l++) {
          var metadataKey = this.metadataWhitelist[l],
              metadata = term.metadata[metadataKey]
  
          if (this.invertedIndex[term][fieldName][docRef][metadataKey] == undefined) {
            this.invertedIndex[term][fieldName][docRef][metadataKey] = []
          }
  
          this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata)
        }
      }
  
    }
  }
  
  /**
   * Calculates the average document length for this index
   *
   * @private
   */
  lunr.Builder.prototype.calculateAverageFieldLengths = function () {
  
    var fieldRefs = Object.keys(this.fieldLengths),
        numberOfFields = fieldRefs.length,
        accumulator = {},
        documentsWithField = {}
  
    for (var i = 0; i < numberOfFields; i++) {
      var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),
          field = fieldRef.fieldName
  
      documentsWithField[field] || (documentsWithField[field] = 0)
      documentsWithField[field] += 1
  
      accumulator[field] || (accumulator[field] = 0)
      accumulator[field] += this.fieldLengths[fieldRef]
    }
  
    for (var i = 0; i < this._fields.length; i++) {
      var field = this._fields[i]
      accumulator[field] = accumulator[field] / documentsWithField[field]
    }
  
    this.averageFieldLength = accumulator
  }
  
  /**
   * Builds a vector space model of every document using lunr.Vector
   *
   * @private
   */
  lunr.Builder.prototype.createFieldVectors = function () {
    var fieldVectors = {},
        fieldRefs = Object.keys(this.fieldTermFrequencies),
        fieldRefsLength = fieldRefs.length
  
    for (var i = 0; i < fieldRefsLength; i++) {
      var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),
          field = fieldRef.fieldName,
          fieldLength = this.fieldLengths[fieldRef],
          fieldVector = new lunr.Vector,
          termFrequencies = this.fieldTermFrequencies[fieldRef],
          terms = Object.keys(termFrequencies),
          termsLength = terms.length
  
      for (var j = 0; j < termsLength; j++) {
        var term = terms[j],
            tf = termFrequencies[term],
            termIndex = this.invertedIndex[term]._index,
            idf = lunr.idf(this.invertedIndex[term], this.documentCount),
            score = idf * ((this._k1 + 1) * tf) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[field])) + tf),
            scoreWithPrecision = Math.round(score * 1000) / 1000
            // Converts 1.23456789 to 1.234.
            // Reducing the precision so that the vectors take up less
            // space when serialised. Doing it now so that they behave
            // the same before and after serialisation. Also, this is
            // the fastest approach to reducing a number's precision in
            // JavaScript.
  
        fieldVector.insert(termIndex, scoreWithPrecision)
      }
  
      fieldVectors[fieldRef] = fieldVector
    }
  
    this.fieldVectors = fieldVectors
  }
  
  /**
   * Creates a token set of all tokens in the index using lunr.TokenSet
   *
   * @private
   */
  lunr.Builder.prototype.createTokenSet = function () {
    this.tokenSet = lunr.TokenSet.fromArray(
      Object.keys(this.invertedIndex).sort()
    )
  }
  
  /**
   * Builds the index, creating an instance of lunr.Index.
   *
   * This completes the indexing process and should only be called
   * once all documents have been added to the index.
   *
   * @returns {lunr.Index}
   */
  lunr.Builder.prototype.build = function () {
    this.calculateAverageFieldLengths()
    this.createFieldVectors()
    this.createTokenSet()
  
    return new lunr.Index({
      invertedIndex: this.invertedIndex,
      fieldVectors: this.fieldVectors,
      tokenSet: this.tokenSet,
      fields: this._fields,
      pipeline: this.searchPipeline
    })
  }
  
  /**
   * Applies a plugin to the index builder.
   *
   * A plugin is a function that is called with the index builder as its context.
   * Plugins can be used to customise or extend the behaviour of the index
   * in some way. A plugin is just a function, that encapsulated the custom
   * behaviour that should be applied when building the index.
   *
   * The plugin function will be called with the index builder as its argument, additional
   * arguments can also be passed when calling use. The function will be called
   * with the index builder as its context.
   *
   * @param {Function} plugin The plugin to apply.
   */
  lunr.Builder.prototype.use = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1)
    args.unshift(this)
    fn.apply(this, args)
  }
  /**
   * Contains and collects metadata about a matching document.
   * A single instance of lunr.MatchData is returned as part of every
   * lunr.Index~Result.
   *
   * @constructor
   * @param {string} term - The term this match data is associated with
   * @param {string} field - The field in which the term was found
   * @param {object} metadata - The metadata recorded about this term in this field
   * @property {object} metadata - A cloned collection of metadata associated with this document.
   * @see {@link lunr.Index~Result}
   */
  lunr.MatchData = function (term, field, metadata) {
    var clonedMetadata = Object.create(null),
        metadataKeys = Object.keys(metadata)
  
    // Cloning the metadata to prevent the original
    // being mutated during match data combination.
    // Metadata is kept in an array within the inverted
    // index so cloning the data can be done with
    // Array#slice
    for (var i = 0; i < metadataKeys.length; i++) {
      var key = metadataKeys[i]
      clonedMetadata[key] = metadata[key].slice()
    }
  
    this.metadata = Object.create(null)
    this.metadata[term] = Object.create(null)
    this.metadata[term][field] = clonedMetadata
  }
  
  /**
   * An instance of lunr.MatchData will be created for every term that matches a
   * document. However only one instance is required in a lunr.Index~Result. This
   * method combines metadata from another instance of lunr.MatchData with this
   * objects metadata.
   *
   * @param {lunr.MatchData} otherMatchData - Another instance of match data to merge with this one.
   * @see {@link lunr.Index~Result}
   */
  lunr.MatchData.prototype.combine = function (otherMatchData) {
    var terms = Object.keys(otherMatchData.metadata)
  
    for (var i = 0; i < terms.length; i++) {
      var term = terms[i],
          fields = Object.keys(otherMatchData.metadata[term])
  
      if (this.metadata[term] == undefined) {
        this.metadata[term] = Object.create(null)
      }
  
      for (var j = 0; j < fields.length; j++) {
        var field = fields[j],
            keys = Object.keys(otherMatchData.metadata[term][field])
  
        if (this.metadata[term][field] == undefined) {
          this.metadata[term][field] = Object.create(null)
        }
  
        for (var k = 0; k < keys.length; k++) {
          var key = keys[k]
  
          if (this.metadata[term][field][key] == undefined) {
            this.metadata[term][field][key] = otherMatchData.metadata[term][field][key]
          } else {
            this.metadata[term][field][key] = this.metadata[term][field][key].concat(otherMatchData.metadata[term][field][key])
          }
  
        }
      }
    }
  }
  /**
   * A lunr.Query provides a programmatic way of defining queries to be performed
   * against a {@link lunr.Index}.
   *
   * Prefer constructing a lunr.Query using the {@link lunr.Index#query} method
   * so the query object is pre-initialized with the right index fields.
   *
   * @constructor
   * @property {lunr.Query~Clause[]} clauses - An array of query clauses.
   * @property {string[]} allFields - An array of all available fields in a lunr.Index.
   */
  lunr.Query = function (allFields) {
    this.clauses = []
    this.allFields = allFields
  }
  
  /**
   * Constants for indicating what kind of automatic wildcard insertion will be used when constructing a query clause.
   *
   * This allows wildcards to be added to the beginning and end of a term without having to manually do any string
   * concatenation.
   *
   * The wildcard constants can be bitwise combined to select both leading and trailing wildcards.
   *
   * @constant
   * @default
   * @property {number} wildcard.NONE - The term will have no wildcards inserted, this is the default behaviour
   * @property {number} wildcard.LEADING - Prepend the term with a wildcard, unless a leading wildcard already exists
   * @property {number} wildcard.TRAILING - Append a wildcard to the term, unless a trailing wildcard already exists
   * @see lunr.Query~Clause
   * @see lunr.Query#clause
   * @see lunr.Query#term
   * @example <caption>query term with trailing wildcard</caption>
   * query.term('foo', { wildcard: lunr.Query.wildcard.TRAILING })
   * @example <caption>query term with leading and trailing wildcard</caption>
   * query.term('foo', {
   *   wildcard: lunr.Query.wildcard.LEADING | lunr.Query.wildcard.TRAILING
   * })
   */
  lunr.Query.wildcard = new String ("*")
  lunr.Query.wildcard.NONE = 0
  lunr.Query.wildcard.LEADING = 1
  lunr.Query.wildcard.TRAILING = 2
  
  /**
   * A single clause in a {@link lunr.Query} contains a term and details on how to
   * match that term against a {@link lunr.Index}.
   *
   * @typedef {Object} lunr.Query~Clause
   * @property {string[]} fields - The fields in an index this clause should be matched against.
   * @property {number} [boost=1] - Any boost that should be applied when matching this clause.
   * @property {number} [editDistance] - Whether the term should have fuzzy matching applied, and how fuzzy the match should be.
   * @property {boolean} [usePipeline] - Whether the term should be passed through the search pipeline.
   * @property {number} [wildcard=0] - Whether the term should have wildcards appended or prepended.
   */
  
  /**
   * Adds a {@link lunr.Query~Clause} to this query.
   *
   * Unless the clause contains the fields to be matched all fields will be matched. In addition
   * a default boost of 1 is applied to the clause.
   *
   * @param {lunr.Query~Clause} clause - The clause to add to this query.
   * @see lunr.Query~Clause
   * @returns {lunr.Query}
   */
  lunr.Query.prototype.clause = function (clause) {
    if (!('fields' in clause)) {
      clause.fields = this.allFields
    }
  
    if (!('boost' in clause)) {
      clause.boost = 1
    }
  
    if (!('usePipeline' in clause)) {
      clause.usePipeline = true
    }
  
    if (!('wildcard' in clause)) {
      clause.wildcard = lunr.Query.wildcard.NONE
    }
  
    if ((clause.wildcard & lunr.Query.wildcard.LEADING) && (clause.term.charAt(0) != lunr.Query.wildcard)) {
      clause.term = "*" + clause.term
    }
  
    if ((clause.wildcard & lunr.Query.wildcard.TRAILING) && (clause.term.slice(-1) != lunr.Query.wildcard)) {
      clause.term = "" + clause.term + "*"
    }
  
    this.clauses.push(clause)
  
    return this
  }
  
  /**
   * Adds a term to the current query, under the covers this will create a {@link lunr.Query~Clause}
   * to the list of clauses that make up this query.
   *
   * @param {string} term - The term to add to the query.
   * @param {Object} [options] - Any additional properties to add to the query clause.
   * @returns {lunr.Query}
   * @see lunr.Query#clause
   * @see lunr.Query~Clause
   * @example <caption>adding a single term to a query</caption>
   * query.term("foo")
   * @example <caption>adding a single term to a query and specifying search fields, term boost and automatic trailing wildcard</caption>
   * query.term("foo", {
   *   fields: ["title"],
   *   boost: 10,
   *   wildcard: lunr.Query.wildcard.TRAILING
   * })
   */
  lunr.Query.prototype.term = function (term, options) {
    var clause = options || {}
    clause.term = term
  
    this.clause(clause)
  
    return this
  }
  lunr.QueryParseError = function (message, start, end) {
    this.name = "QueryParseError"
    this.message = message
    this.start = start
    this.end = end
  }
  
  lunr.QueryParseError.prototype = new Error
  lunr.QueryLexer = function (str) {
    this.lexemes = []
    this.str = str
    this.length = str.length
    this.pos = 0
    this.start = 0
    this.escapeCharPositions = []
  }
  
  lunr.QueryLexer.prototype.run = function () {
    var state = lunr.QueryLexer.lexText
  
    while (state) {
      state = state(this)
    }
  }
  
  lunr.QueryLexer.prototype.sliceString = function () {
    var subSlices = [],
        sliceStart = this.start,
        sliceEnd = this.pos
  
    for (var i = 0; i < this.escapeCharPositions.length; i++) {
      sliceEnd = this.escapeCharPositions[i]
      subSlices.push(this.str.slice(sliceStart, sliceEnd))
      sliceStart = sliceEnd + 1
    }
  
    subSlices.push(this.str.slice(sliceStart, this.pos))
    this.escapeCharPositions.length = 0
  
    return subSlices.join('')
  }
  
  lunr.QueryLexer.prototype.emit = function (type) {
    this.lexemes.push({
      type: type,
      str: this.sliceString(),
      start: this.start,
      end: this.pos
    })
  
    this.start = this.pos
  }
  
  lunr.QueryLexer.prototype.escapeCharacter = function () {
    this.escapeCharPositions.push(this.pos - 1)
    this.pos += 1
  }
  
  lunr.QueryLexer.prototype.next = function () {
    if (this.pos >= this.length) {
      return lunr.QueryLexer.EOS
    }
  
    var char = this.str.charAt(this.pos)
    this.pos += 1
    return char
  }
  
  lunr.QueryLexer.prototype.width = function () {
    return this.pos - this.start
  }
  
  lunr.QueryLexer.prototype.ignore = function () {
    if (this.start == this.pos) {
      this.pos += 1
    }
  
    this.start = this.pos
  }
  
  lunr.QueryLexer.prototype.backup = function () {
    this.pos -= 1
  }
  
  lunr.QueryLexer.prototype.acceptDigitRun = function () {
    var char, charCode
  
    do {
      char = this.next()
      charCode = char.charCodeAt(0)
    } while (charCode > 47 && charCode < 58)
  
    if (char != lunr.QueryLexer.EOS) {
      this.backup()
    }
  }
  
  lunr.QueryLexer.prototype.more = function () {
    return this.pos < this.length
  }
  
  lunr.QueryLexer.EOS = 'EOS'
  lunr.QueryLexer.FIELD = 'FIELD'
  lunr.QueryLexer.TERM = 'TERM'
  lunr.QueryLexer.EDIT_DISTANCE = 'EDIT_DISTANCE'
  lunr.QueryLexer.BOOST = 'BOOST'
  
  lunr.QueryLexer.lexField = function (lexer) {
    lexer.backup()
    lexer.emit(lunr.QueryLexer.FIELD)
    lexer.ignore()
    return lunr.QueryLexer.lexText
  }
  
  lunr.QueryLexer.lexTerm = function (lexer) {
    if (lexer.width() > 1) {
      lexer.backup()
      lexer.emit(lunr.QueryLexer.TERM)
    }
  
    lexer.ignore()
  
    if (lexer.more()) {
      return lunr.QueryLexer.lexText
    }
  }
  
  lunr.QueryLexer.lexEditDistance = function (lexer) {
    lexer.ignore()
    lexer.acceptDigitRun()
    lexer.emit(lunr.QueryLexer.EDIT_DISTANCE)
    return lunr.QueryLexer.lexText
  }
  
  lunr.QueryLexer.lexBoost = function (lexer) {
    lexer.ignore()
    lexer.acceptDigitRun()
    lexer.emit(lunr.QueryLexer.BOOST)
    return lunr.QueryLexer.lexText
  }
  
  lunr.QueryLexer.lexEOS = function (lexer) {
    if (lexer.width() > 0) {
      lexer.emit(lunr.QueryLexer.TERM)
    }
  }
  
  // This matches the separator used when tokenising fields
  // within a document. These should match otherwise it is
  // not possible to search for some tokens within a document.
  //
  // It is possible for the user to change the separator on the
  // tokenizer so it _might_ clash with any other of the special
  // characters already used within the search string, e.g. :.
  //
  // This means that it is possible to change the separator in
  // such a way that makes some words unsearchable using a search
  // string.
  lunr.QueryLexer.termSeparator = lunr.tokenizer.separator
  
  lunr.QueryLexer.lexText = function (lexer) {
    while (true) {
      var char = lexer.next()
  
      if (char == lunr.QueryLexer.EOS) {
        return lunr.QueryLexer.lexEOS
      }
  
      // Escape character is '\'
      if (char.charCodeAt(0) == 92) {
        lexer.escapeCharacter()
        continue
      }
  
      if (char == ":") {
        return lunr.QueryLexer.lexField
      }
  
      if (char == "~") {
        lexer.backup()
        if (lexer.width() > 0) {
          lexer.emit(lunr.QueryLexer.TERM)
        }
        return lunr.QueryLexer.lexEditDistance
      }
  
      if (char == "^") {
        lexer.backup()
        if (lexer.width() > 0) {
          lexer.emit(lunr.QueryLexer.TERM)
        }
        return lunr.QueryLexer.lexBoost
      }
  
      if (char.match(lunr.QueryLexer.termSeparator)) {
        return lunr.QueryLexer.lexTerm
      }
    }
  }
  
  lunr.QueryParser = function (str, query) {
    this.lexer = new lunr.QueryLexer (str)
    this.query = query
    this.currentClause = {}
    this.lexemeIdx = 0
  }
  
  lunr.QueryParser.prototype.parse = function () {
    this.lexer.run()
    this.lexemes = this.lexer.lexemes
  
    var state = lunr.QueryParser.parseFieldOrTerm
  
    while (state) {
      state = state(this)
    }
  
    return this.query
  }
  
  lunr.QueryParser.prototype.peekLexeme = function () {
    return this.lexemes[this.lexemeIdx]
  }
  
  lunr.QueryParser.prototype.consumeLexeme = function () {
    var lexeme = this.peekLexeme()
    this.lexemeIdx += 1
    return lexeme
  }
  
  lunr.QueryParser.prototype.nextClause = function () {
    var completedClause = this.currentClause
    this.query.clause(completedClause)
    this.currentClause = {}
  }
  
  lunr.QueryParser.parseFieldOrTerm = function (parser) {
    var lexeme = parser.peekLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    switch (lexeme.type) {
      case lunr.QueryLexer.FIELD:
        return lunr.QueryParser.parseField
      case lunr.QueryLexer.TERM:
        return lunr.QueryParser.parseTerm
      default:
        var errorMessage = "expected either a field or a term, found " + lexeme.type
  
        if (lexeme.str.length >= 1) {
          errorMessage += " with value '" + lexeme.str + "'"
        }
  
        throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  }
  
  lunr.QueryParser.parseField = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    if (parser.query.allFields.indexOf(lexeme.str) == -1) {
      var possibleFields = parser.query.allFields.map(function (f) { return "'" + f + "'" }).join(', '),
          errorMessage = "unrecognised field '" + lexeme.str + "', possible fields: " + possibleFields
  
      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.fields = [lexeme.str]
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      var errorMessage = "expecting term, found nothing"
      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    switch (nextLexeme.type) {
      case lunr.QueryLexer.TERM:
        return lunr.QueryParser.parseTerm
      default:
        var errorMessage = "expecting term, found '" + nextLexeme.type + "'"
        throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  lunr.QueryParser.parseTerm = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    parser.currentClause.term = lexeme.str.toLowerCase()
  
    if (lexeme.str.indexOf("*") != -1) {
      parser.currentClause.usePipeline = false
    }
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case lunr.QueryLexer.TERM:
        parser.nextClause()
        return lunr.QueryParser.parseTerm
      case lunr.QueryLexer.FIELD:
        parser.nextClause()
        return lunr.QueryParser.parseField
      case lunr.QueryLexer.EDIT_DISTANCE:
        return lunr.QueryParser.parseEditDistance
      case lunr.QueryLexer.BOOST:
        return lunr.QueryParser.parseBoost
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  lunr.QueryParser.parseEditDistance = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    var editDistance = parseInt(lexeme.str, 10)
  
    if (isNaN(editDistance)) {
      var errorMessage = "edit distance must be numeric"
      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.editDistance = editDistance
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case lunr.QueryLexer.TERM:
        parser.nextClause()
        return lunr.QueryParser.parseTerm
      case lunr.QueryLexer.FIELD:
        parser.nextClause()
        return lunr.QueryParser.parseField
      case lunr.QueryLexer.EDIT_DISTANCE:
        return lunr.QueryParser.parseEditDistance
      case lunr.QueryLexer.BOOST:
        return lunr.QueryParser.parseBoost
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  lunr.QueryParser.parseBoost = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    var boost = parseInt(lexeme.str, 10)
  
    if (isNaN(boost)) {
      var errorMessage = "boost must be numeric"
      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.boost = boost
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case lunr.QueryLexer.TERM:
        parser.nextClause()
        return lunr.QueryParser.parseTerm
      case lunr.QueryLexer.FIELD:
        parser.nextClause()
        return lunr.QueryParser.parseField
      case lunr.QueryLexer.EDIT_DISTANCE:
        return lunr.QueryParser.parseEditDistance
      case lunr.QueryLexer.BOOST:
        return lunr.QueryParser.parseBoost
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
    /**
     * export the module via AMD, CommonJS or as a browser global
     * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js
     */
    ;(function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory)
      } else if (typeof exports === 'object') {
        /**
         * Node. Does not work with strict CommonJS, but
         * only CommonJS-like enviroments that support module.exports,
         * like Node.
         */
        module.exports = factory()
      } else {
        // Browser globals (root is window)
        root.lunr = factory()
      }
    }(this, function () {
      /**
       * Just return a value to define the module export.
       * This example returns an object, but the module
       * can return a function as the exported value.
       */
      return lunr
    }))
  })();
</script>


<script>
  function getQueryVariable(variable) {
    var query = window.location.search.substring(1);
    var vars = query.split('&');

    for (var i = 0; i < vars.length; i++) {
      var pair = vars[i].split('=');

      if (pair[0] === variable) {
        return decodeURIComponent(pair[1].replace(/\+/g, '%20'));
      }
    }
  }

  function loadJSON(callback) {   

    var xobj = new XMLHttpRequest();
    xobj.overrideMimeType("application/json");
    xobj.open('GET', '/data/content.json', true); // Replace 'my_data' with the path to your file
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            callback(xobj.responseText);
          }
    };
    xobj.send(null);  
  }

  function displaySearchResults(results, store) {
    var searchResults = document.getElementById('search-results');

    if (results.length) { // Are there any results?
      var appendString = '';

      for (var i = 0; i < results.length; i++) {  // Iterate over the results
        var item = store[results[i].ref];
        appendString += '<li><a href="' + item.url + '"><h3>' + item.title + '</h3></a>';
        appendString += '<p>' + item.summary + '...</p></li>';
      }

      searchResults.innerHTML = appendString;
    } else {
      searchResults.innerHTML = '<li>No results found</li>';
    }
  }

  function init() {
    loadJSON(function(response) {
      // Parse JSON string into object
        var data = JSON.parse(response);
        
        var idx = lunr(function () {
          this.ref('key');
          this.field('title');
          this.field('content');

          for(var key in data) {
            this.add({
              'key': key,
              'title': data[key].title,
              'content': data[key].content
            });
          }
        });

        var searchTerm = getQueryVariable('query');
        var results = idx.search(searchTerm);
        displaySearchResults(results, data);
    });
  }


  init();

  
</script>

<a href="/blog"><svg class="icon icon-arrow-left"><use xlink:href="#icon-arrow-left"></use></svg></a>
<br />

<div id='search-results'></div>